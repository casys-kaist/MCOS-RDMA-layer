
rdma_rmm.ko:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <__get_rdma_work>:
	BUG_ON(nr_refilled == 0);
	return nr_refilled;
}

static struct rdma_work *__get_rdma_work(struct rdma_handle *rh, dma_addr_t dma_addr, size_t size, dma_addr_t rdma_addr, u32 rdma_key)
{
       0:	e8 00 00 00 00       	callq  5 <__get_rdma_work+0x5>
       5:	55                   	push   %rbp
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
       6:	48 8d 87 98 00 00 00 	lea    0x98(%rdi),%rax
       d:	48 89 e5             	mov    %rsp,%rbp
      10:	41 57                	push   %r15
      12:	41 56                	push   %r14
      14:	41 55                	push   %r13
      16:	41 54                	push   %r12
      18:	49 89 d6             	mov    %rdx,%r14
      1b:	53                   	push   %rbx
      1c:	48 89 fb             	mov    %rdi,%rbx
      1f:	48 89 c7             	mov    %rax,%rdi
      22:	49 89 f7             	mov    %rsi,%r15
      25:	49 89 cd             	mov    %rcx,%r13
      28:	45 89 c4             	mov    %r8d,%r12d
      2b:	48 83 ec 08          	sub    $0x8,%rsp
      2f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
      33:	e8 00 00 00 00       	callq  38 <__get_rdma_work+0x38>
	struct rdma_work *rw;
	//might_sleep();

	spin_lock(&rh->rdma_work_head_lock);
	rw = rh->rdma_work_head;
      38:	4c 8b 8b 88 00 00 00 	mov    0x88(%rbx),%r9
	PVOP_VCALL2(lock.queued_spin_lock_slowpath, lock, val);
}

static __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)
{
	PVOP_VCALLEE1(lock.queued_spin_unlock, lock);
      3f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
	rh->rdma_work_head = rh->rdma_work_head->next;
      43:	49 8b 51 10          	mov    0x10(%r9),%rdx
      47:	48 89 c7             	mov    %rax,%rdi
      4a:	48 89 93 88 00 00 00 	mov    %rdx,0x88(%rbx)
      51:	ff 14 25 00 00 00 00 	callq  *0x0
	spin_unlock(&rh->rdma_work_head_lock);

	if (!rh->rdma_work_head)
      58:	48 83 bb 88 00 00 00 	cmpq   $0x0,0x88(%rbx)
      5f:	00 
      60:	74 22                	je     84 <__get_rdma_work+0x84>
		return NULL;

	rw->sgl.addr = dma_addr;
      62:	4d 89 79 18          	mov    %r15,0x18(%r9)
	rw->sgl.length = size;
      66:	45 89 71 20          	mov    %r14d,0x20(%r9)

	rw->wr.remote_addr = rdma_addr;
      6a:	4d 89 69 50          	mov    %r13,0x50(%r9)
	rw->wr.rkey = rdma_key;
      6e:	45 89 61 58          	mov    %r12d,0x58(%r9)
	return rw;
}
      72:	48 83 c4 08          	add    $0x8,%rsp
      76:	4c 89 c8             	mov    %r9,%rax
      79:	5b                   	pop    %rbx
      7a:	41 5c                	pop    %r12
      7c:	41 5d                	pop    %r13
      7e:	41 5e                	pop    %r14
      80:	41 5f                	pop    %r15
      82:	5d                   	pop    %rbp
      83:	c3                   	retq   
		return NULL;
      84:	45 31 c9             	xor    %r9d,%r9d
      87:	eb e9                	jmp    72 <__get_rdma_work+0x72>
      89:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000000090 <cq_comp_handler>:
{
      90:	e8 00 00 00 00       	callq  95 <cq_comp_handler+0x5>
      95:	55                   	push   %rbp
      96:	48 89 e5             	mov    %rsp,%rbp
      99:	41 54                	push   %r12
      9b:	53                   	push   %rbx
				printk("Unknown completion op %d\n", wc.opcode);
      9c:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
{
      a3:	48 89 fb             	mov    %rdi,%rbx
      a6:	48 83 ec 48          	sub    $0x48,%rsp
      aa:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
      b1:	00 00 
      b3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      b7:	31 c0                	xor    %eax,%eax
 * non-negative and < num_entries, then the CQ was emptied.
 */
static inline int ib_poll_cq(struct ib_cq *cq, int num_entries,
			     struct ib_wc *wc)
{
	return cq->device->ops.poll_cq(cq, num_entries, wc);
      b9:	48 8b 03             	mov    (%rbx),%rax
      bc:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
      c0:	be 01 00 00 00       	mov    $0x1,%esi
      c5:	48 89 df             	mov    %rbx,%rdi
      c8:	48 8b 40 28          	mov    0x28(%rax),%rax
      cc:	e8 00 00 00 00       	callq  d1 <cq_comp_handler+0x41>
	while ((ret = ib_poll_cq(cq, 1, &wc)) > 0) {
      d1:	85 c0                	test   %eax,%eax
      d3:	7e 2a                	jle    ff <cq_comp_handler+0x6f>
		if (wc.opcode < 0 || wc.status) {
      d5:	8b 45 b0             	mov    -0x50(%rbp),%eax
      d8:	85 c0                	test   %eax,%eax
      da:	75 dd                	jne    b9 <cq_comp_handler+0x29>
		switch(wc.opcode) {
      dc:	8b 75 b4             	mov    -0x4c(%rbp),%esi
      df:	83 fe 07             	cmp    $0x7,%esi
      e2:	74 d5                	je     b9 <cq_comp_handler+0x29>
      e4:	77 0f                	ja     f5 <cq_comp_handler+0x65>
      e6:	83 fe 02             	cmp    $0x2,%esi
      e9:	76 ce                	jbe    b9 <cq_comp_handler+0x29>
				printk("Unknown completion op %d\n", wc.opcode);
      eb:	4c 89 e7             	mov    %r12,%rdi
      ee:	e8 00 00 00 00       	callq  f3 <cq_comp_handler+0x63>
				break;
      f3:	eb c4                	jmp    b9 <cq_comp_handler+0x29>
		switch(wc.opcode) {
      f5:	81 fe 80 00 00 00    	cmp    $0x80,%esi
      fb:	74 bc                	je     b9 <cq_comp_handler+0x29>
      fd:	eb ec                	jmp    eb <cq_comp_handler+0x5b>
 *        completion notification event.
 */
static inline int ib_req_notify_cq(struct ib_cq *cq,
				   enum ib_cq_notify_flags flags)
{
	return cq->device->ops.req_notify_cq(cq, flags);
      ff:	48 8b 03             	mov    (%rbx),%rax
     102:	be 06 00 00 00       	mov    $0x6,%esi
     107:	48 89 df             	mov    %rbx,%rdi
     10a:	48 8b 40 38          	mov    0x38(%rax),%rax
     10e:	e8 00 00 00 00       	callq  113 <cq_comp_handler+0x83>
	if (ret > 0) goto retry;
     113:	85 c0                	test   %eax,%eax
     115:	7f a2                	jg     b9 <cq_comp_handler+0x29>
}
     117:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
     11b:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
     122:	00 00 
     124:	75 09                	jne    12f <cq_comp_handler+0x9f>
     126:	48 83 c4 48          	add    $0x48,%rsp
     12a:	5b                   	pop    %rbx
     12b:	41 5c                	pop    %r12
     12d:	5d                   	pop    %rbp
     12e:	c3                   	retq   
     12f:	e8 00 00 00 00       	callq  134 <cq_comp_handler+0xa4>
     134:	66 90                	xchg   %ax,%ax
     136:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     13d:	00 00 00 

0000000000000140 <__put_rdma_work>:

static void __put_rdma_work(struct rdma_handle *rh, struct rdma_work *rw)
{
     140:	e8 00 00 00 00       	callq  145 <__put_rdma_work+0x5>
     145:	55                   	push   %rbp
     146:	48 89 e5             	mov    %rsp,%rbp
     149:	41 55                	push   %r13
     14b:	41 54                	push   %r12
     14d:	49 89 fc             	mov    %rdi,%r12
     150:	53                   	push   %rbx
     151:	49 89 f5             	mov    %rsi,%r13
     154:	49 8d 9c 24 98 00 00 	lea    0x98(%r12),%rbx
     15b:	00 
	might_sleep();
     15c:	e8 00 00 00 00       	callq  161 <__put_rdma_work+0x21>
     161:	48 89 df             	mov    %rbx,%rdi
     164:	e8 00 00 00 00       	callq  169 <__put_rdma_work+0x29>
	spin_lock(&rh->rdma_work_head_lock);
	rw->next = rh->rdma_work_head;
     169:	49 8b 84 24 88 00 00 	mov    0x88(%r12),%rax
     170:	00 
     171:	48 89 df             	mov    %rbx,%rdi
     174:	49 89 45 10          	mov    %rax,0x10(%r13)
	rh->rdma_work_head = rw;
     178:	4d 89 ac 24 88 00 00 	mov    %r13,0x88(%r12)
     17f:	00 
     180:	ff 14 25 00 00 00 00 	callq  *0x0
	spin_unlock(&rh->rdma_work_head_lock);
}
     187:	5b                   	pop    %rbx
     188:	41 5c                	pop    %r12
     18a:	41 5d                	pop    %r13
     18c:	5d                   	pop    %rbp
     18d:	c3                   	retq   
     18e:	66 90                	xchg   %ax,%ax

0000000000000190 <cm_client_event_handler>:

/****************************************************************************
 * Client-side connection handling
 */
int cm_client_event_handler(struct rdma_cm_id *cm_id, struct rdma_cm_event *cm_event)
{
     190:	e8 00 00 00 00       	callq  195 <cm_client_event_handler+0x5>
     195:	55                   	push   %rbp
	struct rdma_handle *rh = cm_id->context;

	switch (cm_event->event) {
     196:	8b 36                	mov    (%rsi),%esi
	struct rdma_handle *rh = cm_id->context;
     198:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
{
     19c:	48 89 e5             	mov    %rsp,%rbp
	switch (cm_event->event) {
     19f:	83 fe 06             	cmp    $0x6,%esi
     1a2:	74 45                	je     1e9 <cm_client_event_handler+0x59>
     1a4:	77 20                	ja     1c6 <cm_client_event_handler+0x36>
     1a6:	83 fe 01             	cmp    $0x1,%esi
     1a9:	74 7d                	je     228 <cm_client_event_handler+0x98>
     1ab:	72 49                	jb     1f6 <cm_client_event_handler+0x66>
     1ad:	83 fe 02             	cmp    $0x2,%esi
     1b0:	75 58                	jne    20a <cm_client_event_handler+0x7a>
		case RDMA_CM_EVENT_ADDR_RESOLVED:
			rh->state = RDMA_ADDR_RESOLVED;
			complete(&rh->cm_done);
			break;
		case RDMA_CM_EVENT_ROUTE_RESOLVED:
			rh->state = RDMA_ROUTE_RESOLVED;
     1b2:	c7 47 04 02 00 00 00 	movl   $0x2,0x4(%rdi)
			complete(&rh->cm_done);
     1b9:	48 83 c7 08          	add    $0x8,%rdi
     1bd:	e8 00 00 00 00       	callq  1c2 <cm_client_event_handler+0x32>
		default:
			printk(PFX "Unhandled client event %d\n", cm_event->event);
			break;
	}
	return 0;
}
     1c2:	31 c0                	xor    %eax,%eax
     1c4:	5d                   	pop    %rbp
     1c5:	c3                   	retq   
	switch (cm_event->event) {
     1c6:	83 fe 09             	cmp    $0x9,%esi
     1c9:	75 14                	jne    1df <cm_client_event_handler+0x4f>
			rh->state = RDMA_CONNECTED;
     1cb:	c7 47 04 04 00 00 00 	movl   $0x4,0x4(%rdi)
			complete(&rh->cm_done);
     1d2:	48 83 c7 08          	add    $0x8,%rdi
     1d6:	e8 00 00 00 00       	callq  1db <cm_client_event_handler+0x4b>
}
     1db:	31 c0                	xor    %eax,%eax
     1dd:	5d                   	pop    %rbp
     1de:	c3                   	retq   
	switch (cm_event->event) {
     1df:	83 fe 0a             	cmp    $0xa,%esi
     1e2:	74 34                	je     218 <cm_client_event_handler+0x88>
     1e4:	83 fe 08             	cmp    $0x8,%esi
     1e7:	75 21                	jne    20a <cm_client_event_handler+0x7a>
			complete(&rh->cm_done);
     1e9:	48 83 c7 08          	add    $0x8,%rdi
     1ed:	e8 00 00 00 00       	callq  1f2 <cm_client_event_handler+0x62>
}
     1f2:	31 c0                	xor    %eax,%eax
     1f4:	5d                   	pop    %rbp
     1f5:	c3                   	retq   
			rh->state = RDMA_ADDR_RESOLVED;
     1f6:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%rdi)
			complete(&rh->cm_done);
     1fd:	48 83 c7 08          	add    $0x8,%rdi
     201:	e8 00 00 00 00       	callq  206 <cm_client_event_handler+0x76>
}
     206:	31 c0                	xor    %eax,%eax
     208:	5d                   	pop    %rbp
     209:	c3                   	retq   
			printk(PFX "Unhandled client event %d\n", cm_event->event);
     20a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     211:	e8 00 00 00 00       	callq  216 <cm_client_event_handler+0x86>
			break;
     216:	eb aa                	jmp    1c2 <cm_client_event_handler+0x32>
			printk(PFX "Disconnected from %d\n", rh->nid);
     218:	8b 37                	mov    (%rdi),%esi
     21a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     221:	e8 00 00 00 00       	callq  226 <cm_client_event_handler+0x96>
			break;
     226:	eb 9a                	jmp    1c2 <cm_client_event_handler+0x32>
			printk(PFX "addr error\n");
     228:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     22f:	e8 00 00 00 00       	callq  234 <cm_client_event_handler+0xa4>
			break;
     234:	eb 8c                	jmp    1c2 <cm_client_event_handler+0x32>
     236:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     23d:	00 00 00 

0000000000000240 <__setup_pd_cq_qp>:
{
     240:	e8 00 00 00 00       	callq  245 <__setup_pd_cq_qp+0x5>
     245:	55                   	push   %rbp
     246:	48 89 e5             	mov    %rsp,%rbp
     249:	41 55                	push   %r13
     24b:	41 54                	push   %r12
     24d:	53                   	push   %rbx
     24e:	48 83 ec 68          	sub    $0x68,%rsp
	BUG_ON(rh->state != RDMA_ROUTE_RESOLVED && "for rh->device");
     252:	83 7f 04 02          	cmpl   $0x2,0x4(%rdi)
     256:	0f 85 b9 01 00 00    	jne    415 <__setup_pd_cq_qp+0x1d5>
	DEBUG_LOG(PFX "alloc pd\n");
     25c:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 262 <__setup_pd_cq_qp+0x22>
     262:	48 89 fb             	mov    %rdi,%rbx
     265:	85 c9                	test   %ecx,%ecx
     267:	0f 85 bd 00 00 00    	jne    32a <__setup_pd_cq_qp+0xea>
	if (!rdma_pd) {
     26d:	48 83 3d 00 00 00 00 	cmpq   $0x0,0x0(%rip)        # 275 <__setup_pd_cq_qp+0x35>
     274:	00 
     275:	0f 84 c5 00 00 00    	je     340 <__setup_pd_cq_qp+0x100>
	if (!rdma_cq) {
     27b:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 282 <__setup_pd_cq_qp+0x42>
     282:	4c 8d 65 80          	lea    -0x80(%rbp),%r12
     286:	48 85 d2             	test   %rdx,%rdx
     289:	0f 84 f8 00 00 00    	je     387 <__setup_pd_cq_qp+0x147>
	DEBUG_LOG(PFX "create qp\n");
     28f:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 295 <__setup_pd_cq_qp+0x55>
	rh->cq = rdma_cq;
     295:	48 89 93 38 01 00 00 	mov    %rdx,0x138(%rbx)
	DEBUG_LOG(PFX "create qp\n");
     29c:	85 c0                	test   %eax,%eax
     29e:	0f 85 83 01 00 00    	jne    427 <__setup_pd_cq_qp+0x1e7>
		struct ib_qp_init_attr qp_attr = {
     2a4:	31 c0                	xor    %eax,%eax
     2a6:	b9 0d 00 00 00       	mov    $0xd,%ecx
     2ab:	4c 89 e7             	mov    %r12,%rdi
     2ae:	f3 48 ab             	rep stos %rax,%es:(%rdi)
		ret = rdma_create_qp(rh->cm_id, rdma_pd, &qp_attr);
     2b1:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2b8 <__setup_pd_cq_qp+0x78>
     2b8:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
		struct ib_qp_init_attr qp_attr = {
     2bf:	48 b8 08 00 00 00 0a 	movabs $0x40a00000008,%rax
     2c6:	04 00 00 
     2c9:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
     2cd:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
		ret = rdma_create_qp(rh->cm_id, rdma_pd, &qp_attr);
     2d1:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
		struct ib_qp_init_attr qp_attr = {
     2d5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
     2d9:	48 b8 0a 00 00 00 0a 	movabs $0xa0000000a,%rax
     2e0:	00 00 00 
     2e3:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
     2e7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
     2eb:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
     2f2:	c7 45 cc 02 00 00 00 	movl   $0x2,-0x34(%rbp)
		ret = rdma_create_qp(rh->cm_id, rdma_pd, &qp_attr);
     2f9:	e8 00 00 00 00       	callq  2fe <__setup_pd_cq_qp+0xbe>
		if (ret) 
     2fe:	85 c0                	test   %eax,%eax
     300:	74 0b                	je     30d <__setup_pd_cq_qp+0xcd>
}
     302:	48 83 c4 68          	add    $0x68,%rsp
     306:	5b                   	pop    %rbx
     307:	41 5c                	pop    %r12
     309:	41 5d                	pop    %r13
     30b:	5d                   	pop    %rbp
     30c:	c3                   	retq   
		rh->qp = rh->cm_id->qp;
     30d:	48 8b 93 28 01 00 00 	mov    0x128(%rbx),%rdx
     314:	48 8b 52 10          	mov    0x10(%rdx),%rdx
     318:	48 89 93 40 01 00 00 	mov    %rdx,0x140(%rbx)
}
     31f:	48 83 c4 68          	add    $0x68,%rsp
     323:	5b                   	pop    %rbx
     324:	41 5c                	pop    %r12
     326:	41 5d                	pop    %r13
     328:	5d                   	pop    %rbp
     329:	c3                   	retq   
	DEBUG_LOG(PFX "alloc pd\n");
     32a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     331:	e8 00 00 00 00       	callq  336 <__setup_pd_cq_qp+0xf6>
	if (!rdma_pd) {
     336:	48 83 3d 00 00 00 00 	cmpq   $0x0,0x0(%rip)        # 33e <__setup_pd_cq_qp+0xfe>
     33d:	00 
     33e:	75 28                	jne    368 <__setup_pd_cq_qp+0x128>
		rdma_pd = ib_alloc_pd(rh->device, 0);
     340:	48 8b bb 30 01 00 00 	mov    0x130(%rbx),%rdi
     347:	31 f6                	xor    %esi,%esi
     349:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
     350:	e8 00 00 00 00       	callq  355 <__setup_pd_cq_qp+0x115>
		if (IS_ERR(rdma_pd)) {
     355:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
		rdma_pd = ib_alloc_pd(rh->device, 0);
     35b:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 362 <__setup_pd_cq_qp+0x122>
		if (IS_ERR(rdma_pd)) {
     362:	0f 87 af 00 00 00    	ja     417 <__setup_pd_cq_qp+0x1d7>
	DEBUG_LOG(PFX "alloc cq\n");
     368:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 36e <__setup_pd_cq_qp+0x12e>
     36e:	85 d2                	test   %edx,%edx
     370:	0f 84 05 ff ff ff    	je     27b <__setup_pd_cq_qp+0x3b>
     376:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     37d:	e8 00 00 00 00       	callq  382 <__setup_pd_cq_qp+0x142>
     382:	e9 f4 fe ff ff       	jmpq   27b <__setup_pd_cq_qp+0x3b>
		rdma_cq = ib_create_cq(
     387:	48 8b bb 30 01 00 00 	mov    0x130(%rbx),%rdi
     38e:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
     395:	4d 89 e0             	mov    %r12,%r8
     398:	48 89 d9             	mov    %rbx,%rcx
     39b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
		struct ib_cq_init_attr cq_attr = {
     3a2:	48 c7 45 84 00 00 00 	movq   $0x0,-0x7c(%rbp)
     3a9:	00 
     3aa:	c7 45 80 40 a2 00 00 	movl   $0xa240,-0x80(%rbp)
		rdma_cq = ib_create_cq(
     3b1:	e8 00 00 00 00       	callq  3b6 <__setup_pd_cq_qp+0x176>
		if (IS_ERR(rdma_cq)) {
     3b6:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
		rdma_cq = ib_create_cq(
     3bc:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 3c3 <__setup_pd_cq_qp+0x183>
		if (IS_ERR(rdma_cq)) {
     3c3:	0f 87 39 ff ff ff    	ja     302 <__setup_pd_cq_qp+0xc2>
		polling_k = kthread_run(polling_cq, rdma_cq, "polling_cq");
     3c9:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
     3d0:	ba ff ff ff ff       	mov    $0xffffffff,%edx
     3d5:	48 89 c6             	mov    %rax,%rsi
     3d8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     3df:	e8 00 00 00 00       	callq  3e4 <__setup_pd_cq_qp+0x1a4>
     3e4:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
     3ea:	49 89 c5             	mov    %rax,%r13
     3ed:	77 08                	ja     3f7 <__setup_pd_cq_qp+0x1b7>
     3ef:	48 89 c7             	mov    %rax,%rdi
     3f2:	e8 00 00 00 00       	callq  3f7 <__setup_pd_cq_qp+0x1b7>
	int ret = 0;
     3f7:	31 c0                	xor    %eax,%eax
		if (!polling_k)
     3f9:	4d 85 ed             	test   %r13,%r13
		polling_k = kthread_run(polling_cq, rdma_cq, "polling_cq");
     3fc:	4c 89 2d 00 00 00 00 	mov    %r13,0x0(%rip)        # 403 <__setup_pd_cq_qp+0x1c3>
		if (!polling_k)
     403:	0f 84 f9 fe ff ff    	je     302 <__setup_pd_cq_qp+0xc2>
     409:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 410 <__setup_pd_cq_qp+0x1d0>
     410:	e9 7a fe ff ff       	jmpq   28f <__setup_pd_cq_qp+0x4f>
     415:	0f 0b                	ud2    
			rdma_pd = NULL;
     417:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 422 <__setup_pd_cq_qp+0x1e2>
     41e:	00 00 00 00 
			goto out_err;
     422:	e9 db fe ff ff       	jmpq   302 <__setup_pd_cq_qp+0xc2>
	DEBUG_LOG(PFX "create qp\n");
     427:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     42e:	e8 00 00 00 00       	callq  433 <__setup_pd_cq_qp+0x1f3>
     433:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 43a <__setup_pd_cq_qp+0x1fa>
     43a:	e9 65 fe ff ff       	jmpq   2a4 <__setup_pd_cq_qp+0x64>
     43f:	90                   	nop

0000000000000440 <cm_server_event_handler>:
	printk(PFX "Disconnected from %d\n", rh->nid);
	return 0;
}

int cm_server_event_handler(struct rdma_cm_id *cm_id, struct rdma_cm_event *cm_event)
{
     440:	e8 00 00 00 00       	callq  445 <cm_server_event_handler+0x5>
     445:	55                   	push   %rbp
     446:	48 89 e5             	mov    %rsp,%rbp
     449:	41 55                	push   %r13
     44b:	41 54                	push   %r12
     44d:	53                   	push   %rbx
	int ret = 0;
	switch (cm_event->event) {
     44e:	8b 06                	mov    (%rsi),%eax
{
     450:	49 89 fd             	mov    %rdi,%r13
	switch (cm_event->event) {
     453:	83 f8 09             	cmp    $0x9,%eax
     456:	0f 84 06 01 00 00    	je     562 <cm_server_event_handler+0x122>
     45c:	83 f8 0a             	cmp    $0xa,%eax
     45f:	0f 84 e2 00 00 00    	je     547 <cm_server_event_handler+0x107>
     465:	83 f8 04             	cmp    $0x4,%eax
     468:	0f 85 c9 00 00 00    	jne    537 <cm_server_event_handler+0xf7>
	int connect_type = *(int *)cm_event->param.conn.private_data;
     46e:	48 8b 46 08          	mov    0x8(%rsi),%rax
	if (connect_type == CONNECTION_FETCH) {
     472:	8b 30                	mov    (%rax),%esi
     474:	85 f6                	test   %esi,%esi
     476:	75 3f                	jne    4b7 <cm_server_event_handler+0x77>
		DEBUG_LOG(PFX "atomic inc\n");
     478:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 47e <cm_server_event_handler+0x3e>
     47e:	85 c9                	test   %ecx,%ecx
     480:	0f 85 a0 00 00 00    	jne    526 <cm_server_event_handler+0xe6>
 *
 * Atomically adds @i to @v and returns @i + @v
 */
static __always_inline int arch_atomic_add_return(int i, atomic_t *v)
{
	return i + xadd(&v->counter, i);
     486:	b8 01 00 00 00       	mov    $0x1,%eax
     48b:	f0 0f c1 05 00 00 00 	lock xadd %eax,0x0(%rip)        # 493 <cm_server_event_handler+0x53>
     492:	00 
		DEBUG_LOG(PFX "nid: %d\n", nid);
     493:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 499 <cm_server_event_handler+0x59>
     499:	44 8d 60 01          	lea    0x1(%rax),%r12d
     49d:	85 d2                	test   %edx,%edx
     49f:	75 71                	jne    512 <cm_server_event_handler+0xd2>
		if (nid == MAX_NUM_NODES)
     4a1:	41 83 fc 20          	cmp    $0x20,%r12d
     4a5:	74 62                	je     509 <cm_server_event_handler+0xc9>
		rh = rdma_handles[nid];
     4a7:	49 63 c4             	movslq %r12d,%rax
     4aa:	48 8b 1c c5 00 00 00 	mov    0x0(,%rax,8),%rbx
     4b1:	00 
		rh->nid = nid;
     4b2:	44 89 23             	mov    %r12d,(%rbx)
     4b5:	eb 22                	jmp    4d9 <cm_server_event_handler+0x99>
     4b7:	b8 01 00 00 00       	mov    $0x1,%eax
     4bc:	f0 0f c1 05 00 00 00 	lock xadd %eax,0x0(%rip)        # 4c4 <cm_server_event_handler+0x84>
     4c3:	00 
     4c4:	83 c0 01             	add    $0x1,%eax
		if (nid == MAX_NUM_NODES)
     4c7:	83 f8 20             	cmp    $0x20,%eax
     4ca:	74 3d                	je     509 <cm_server_event_handler+0xc9>
		rh = rdma_handles_evic[nid];
     4cc:	48 63 d0             	movslq %eax,%rdx
     4cf:	48 8b 1c d5 00 00 00 	mov    0x0(,%rdx,8),%rbx
     4d6:	00 
		rh->nid = nid;
     4d7:	89 03                	mov    %eax,(%rbx)
	cm_id->context = rh;
     4d9:	49 89 5d 08          	mov    %rbx,0x8(%r13)
	rh->cm_id = cm_id;
     4dd:	4c 89 ab 28 01 00 00 	mov    %r13,0x128(%rbx)
	rh->device = cm_id->device;
     4e4:	49 8b 45 00          	mov    0x0(%r13),%rax
	rh->state = RDMA_ROUTE_RESOLVED;
     4e8:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%rbx)
	rh->device = cm_id->device;
     4ef:	48 89 83 30 01 00 00 	mov    %rax,0x130(%rbx)
	DEBUG_LOG(PFX "connecting done\n");
     4f6:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 4fc <cm_server_event_handler+0xbc>
     4fc:	85 c0                	test   %eax,%eax
     4fe:	75 7d                	jne    57d <cm_server_event_handler+0x13d>
	complete(&rh->cm_done);
     500:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
     504:	e8 00 00 00 00       	callq  509 <cm_server_event_handler+0xc9>
		default:
			printk(PFX "Unhandled server event %d\n", cm_event->event);
			break;
	}
	return 0;
}
     509:	5b                   	pop    %rbx
     50a:	31 c0                	xor    %eax,%eax
     50c:	41 5c                	pop    %r12
     50e:	41 5d                	pop    %r13
     510:	5d                   	pop    %rbp
     511:	c3                   	retq   
		DEBUG_LOG(PFX "nid: %d\n", nid);
     512:	44 89 e6             	mov    %r12d,%esi
     515:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     51c:	e8 00 00 00 00       	callq  521 <cm_server_event_handler+0xe1>
     521:	e9 7b ff ff ff       	jmpq   4a1 <cm_server_event_handler+0x61>
		DEBUG_LOG(PFX "atomic inc\n");
     526:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     52d:	e8 00 00 00 00       	callq  532 <cm_server_event_handler+0xf2>
     532:	e9 4f ff ff ff       	jmpq   486 <cm_server_event_handler+0x46>
			printk(PFX "Unhandled server event %d\n", cm_event->event);
     537:	89 c6                	mov    %eax,%esi
     539:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     540:	e8 00 00 00 00       	callq  545 <cm_server_event_handler+0x105>
			break;
     545:	eb c2                	jmp    509 <cm_server_event_handler+0xc9>
			ret = __on_client_disconnected(cm_id, cm_event);
     547:	48 8b 47 08          	mov    0x8(%rdi),%rax
	printk(PFX "Disconnected from %d\n", rh->nid);
     54b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     552:	8b 30                	mov    (%rax),%esi
	rh->state = RDMA_CLOSED;
     554:	c7 40 04 06 00 00 00 	movl   $0x6,0x4(%rax)
	printk(PFX "Disconnected from %d\n", rh->nid);
     55b:	e8 00 00 00 00       	callq  560 <cm_server_event_handler+0x120>
			break;
     560:	eb a7                	jmp    509 <cm_server_event_handler+0xc9>
			ret = __on_client_connected(cm_id, cm_event);
     562:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
	printk(PFX "Connected to %d\n", rh->nid);
     566:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     56d:	8b 33                	mov    (%rbx),%esi
	rh->state = RDMA_CONNECTED;
     56f:	c7 43 04 04 00 00 00 	movl   $0x4,0x4(%rbx)
	printk(PFX "Connected to %d\n", rh->nid);
     576:	e8 00 00 00 00       	callq  57b <cm_server_event_handler+0x13b>
     57b:	eb 83                	jmp    500 <cm_server_event_handler+0xc0>
	DEBUG_LOG(PFX "connecting done\n");
     57d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     584:	e8 00 00 00 00       	callq  589 <cm_server_event_handler+0x149>
     589:	e9 72 ff ff ff       	jmpq   500 <cm_server_event_handler+0xc0>
     58e:	66 90                	xchg   %ax,%ax

0000000000000590 <dma_unmap_page_attrs.constprop.31>:
	debug_dma_map_page(dev, page, offset, size, dir, addr);

	return addr;
}

static inline void dma_unmap_page_attrs(struct device *dev, dma_addr_t addr,
     590:	55                   	push   %rbp
	if (dev && dev->dma_ops)
     591:	48 85 ff             	test   %rdi,%rdi
static inline void dma_unmap_page_attrs(struct device *dev, dma_addr_t addr,
     594:	48 89 e5             	mov    %rsp,%rbp
	if (dev && dev->dma_ops)
     597:	74 1f                	je     5b8 <dma_unmap_page_attrs.constprop.31+0x28>
     599:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
     5a0:	48 85 c0             	test   %rax,%rax
     5a3:	74 13                	je     5b8 <dma_unmap_page_attrs.constprop.31+0x28>
	const struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (dma_is_direct(ops))
		dma_direct_unmap_page(dev, addr, size, dir, attrs);
	else if (ops->unmap_page)
     5a5:	48 8b 40 28          	mov    0x28(%rax),%rax
     5a9:	48 85 c0             	test   %rax,%rax
     5ac:	74 08                	je     5b6 <dma_unmap_page_attrs.constprop.31+0x26>
		ops->unmap_page(dev, addr, size, dir, attrs);
     5ae:	45 31 c0             	xor    %r8d,%r8d
     5b1:	e8 00 00 00 00       	callq  5b6 <dma_unmap_page_attrs.constprop.31+0x26>
	debug_dma_unmap_page(dev, addr, size, dir);
}
     5b6:	5d                   	pop    %rbp
     5b7:	c3                   	retq   

extern const struct dma_map_ops *dma_ops;

static inline const struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
{
	return dma_ops;
     5b8:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 5bf <dma_unmap_page_attrs.constprop.31+0x2f>
	if (dma_is_direct(ops))
     5bf:	48 85 c0             	test   %rax,%rax
     5c2:	75 e1                	jne    5a5 <dma_unmap_page_attrs.constprop.31+0x15>
		dma_direct_unmap_page(dev, addr, size, dir, attrs);
     5c4:	45 31 c0             	xor    %r8d,%r8d
     5c7:	e8 00 00 00 00       	callq  5cc <dma_unmap_page_attrs.constprop.31+0x3c>
}
     5cc:	5d                   	pop    %rbp
     5cd:	c3                   	retq   
     5ce:	66 90                	xchg   %ax,%ax

00000000000005d0 <__send_dma_addr>:
{
     5d0:	e8 00 00 00 00       	callq  5d5 <__send_dma_addr+0x5>
     5d5:	55                   	push   %rbp
     5d6:	48 89 e5             	mov    %rsp,%rbp
     5d9:	41 57                	push   %r15
     5db:	41 56                	push   %r14
     5dd:	41 55                	push   %r13
     5df:	41 54                	push   %r12
     5e1:	49 89 fc             	mov    %rdi,%r12
     5e4:	53                   	push   %rbx
     5e5:	49 89 f7             	mov    %rsi,%r15
     5e8:	49 89 d6             	mov    %rdx,%r14
		index = kmalloc_index(size);

		if (!index)
			return ZERO_SIZE_PTR;

		return kmem_cache_alloc_trace(
     5eb:	be c0 0c 00 00       	mov    $0xcc0,%esi
     5f0:	ba 18 00 00 00       	mov    $0x18,%edx
     5f5:	48 83 ec 08          	sub    $0x8,%rsp
     5f9:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 600 <__send_dma_addr+0x30>
	const struct ib_send_wr *bad_wr = NULL;
     600:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
     607:	00 
     608:	e8 00 00 00 00       	callq  60d <__send_dma_addr+0x3d>
	if (!rp) 
     60d:	48 85 c0             	test   %rax,%rax
     610:	0f 84 67 01 00 00    	je     77d <__send_dma_addr+0x1ad>
     616:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 61d <__send_dma_addr+0x4d>
     61d:	ba 60 00 00 00       	mov    $0x60,%edx
     622:	be c0 0c 00 00       	mov    $0xcc0,%esi
     627:	49 89 c5             	mov    %rax,%r13
     62a:	e8 00 00 00 00       	callq  62f <__send_dma_addr+0x5f>
	if (!sw) 
     62f:	48 85 c0             	test   %rax,%rax
     632:	48 89 c3             	mov    %rax,%rbx
     635:	0f 84 42 01 00 00    	je     77d <__send_dma_addr+0x1ad>
	rp->rkey = rh->mr->rkey;
     63b:	49 8b 84 24 48 01 00 	mov    0x148(%r12),%rax
     642:	00 

static inline dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
		size_t size, enum dma_data_direction dir, unsigned long attrs)
{
	debug_dma_map_single(dev, ptr, size);
	return dma_map_page_attrs(dev, virt_to_page(ptr), offset_in_page(ptr),
     643:	4c 89 ea             	mov    %r13,%rdx
     646:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
     64c:	8b 40 14             	mov    0x14(%rax),%eax
	rp->addr = addr;
     64f:	4d 89 7d 08          	mov    %r15,0x8(%r13)
	rp->size = size;
     653:	4d 89 75 10          	mov    %r14,0x10(%r13)
	rp->rkey = rh->mr->rkey;
     657:	41 89 45 00          	mov    %eax,0x0(%r13)
	dma_addr = ib_dma_map_single(rh->device, rp,
     65b:	49 8b 84 24 30 01 00 	mov    0x130(%r12),%rax
     662:	00 
     663:	48 8b 38             	mov    (%rax),%rdi
     666:	b8 00 00 00 80       	mov    $0x80000000,%eax
     66b:	4c 01 e8             	add    %r13,%rax
     66e:	0f 82 5d 01 00 00    	jb     7d1 <__send_dma_addr+0x201>
static inline unsigned long __phys_addr_nodebug(unsigned long x)
{
	unsigned long y = x - __START_KERNEL_map;

	/* use the carry flag to determine if x was < __START_KERNEL_map */
	x = y + ((x > y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));
     674:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
     67b:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 682 <__send_dma_addr+0xb2>
     682:	48 01 c6             	add    %rax,%rsi
     685:	48 c1 ee 0c          	shr    $0xc,%rsi
     689:	48 c1 e6 06          	shl    $0x6,%rsi
     68d:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 694 <__send_dma_addr+0xc4>
	if (dev && dev->dma_ops)
     694:	48 85 ff             	test   %rdi,%rdi
     697:	74 28                	je     6c1 <__send_dma_addr+0xf1>
     699:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
     6a0:	48 85 c0             	test   %rax,%rax
     6a3:	74 1c                	je     6c1 <__send_dma_addr+0xf1>
		addr = ops->map_page(dev, page, offset, size, dir, attrs);
     6a5:	48 8b 40 20          	mov    0x20(%rax),%rax
     6a9:	45 31 c9             	xor    %r9d,%r9d
     6ac:	41 b8 01 00 00 00    	mov    $0x1,%r8d
     6b2:	b9 18 00 00 00       	mov    $0x18,%ecx
     6b7:	e8 00 00 00 00       	callq  6bc <__send_dma_addr+0xec>
     6bc:	49 89 c6             	mov    %rax,%r14
     6bf:	eb 22                	jmp    6e3 <__send_dma_addr+0x113>
     6c1:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 6c8 <__send_dma_addr+0xf8>
	if (dma_is_direct(ops))
     6c8:	48 85 c0             	test   %rax,%rax
     6cb:	75 d8                	jne    6a5 <__send_dma_addr+0xd5>
		addr = dma_direct_map_page(dev, page, offset, size, dir, attrs);
     6cd:	45 31 c9             	xor    %r9d,%r9d
     6d0:	41 b8 01 00 00 00    	mov    $0x1,%r8d
     6d6:	b9 18 00 00 00       	mov    $0x18,%ecx
     6db:	e8 00 00 00 00       	callq  6e0 <__send_dma_addr+0x110>
     6e0:	49 89 c6             	mov    %rax,%r14
	if (dma_addr == DMA_MAPPING_ERROR)
     6e3:	49 83 fe ff          	cmp    $0xffffffffffffffff,%r14
     6e7:	0f 84 97 00 00 00    	je     784 <__send_dma_addr+0x1b4>
	sgl->lkey = rdma_pd->local_dma_lkey;
     6ed:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 6f4 <__send_dma_addr+0x124>
	sw->next = NULL;
     6f4:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
     6fb:	00 
	wr = &sw->wr;
     6fc:	48 8d 73 28          	lea    0x28(%rbx),%rsi
	sw->work_type = WORK_TYPE_SEND_ADDR;
     700:	c7 03 04 00 00 00    	movl   $0x4,(%rbx)
	sw->addr = rp;
     706:	4c 89 6b 50          	mov    %r13,0x50(%rbx)
	return qp->device->ops.post_send(qp, send_wr, bad_send_wr ? : &dummy);
     70a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
	sw->rh = rh;
     70e:	4c 89 63 08          	mov    %r12,0x8(%rbx)
	sgl->addr = dma_addr;
     712:	4c 89 73 18          	mov    %r14,0x18(%rbx)
	sgl->length = sizeof(struct pool_info);
     716:	c7 43 20 18 00 00 00 	movl   $0x18,0x20(%rbx)
	sgl->lkey = rdma_pd->local_dma_lkey;
     71d:	8b 00                	mov    (%rax),%eax
	ret = ib_post_send(rh->qp, wr, &bad_wr);
     71f:	49 8b bc 24 40 01 00 	mov    0x140(%r12),%rdi
     726:	00 
	wr->opcode = IB_WR_SEND;
     727:	c7 43 44 02 00 00 00 	movl   $0x2,0x44(%rbx)
	wr->send_flags = IB_SEND_SIGNALED;
     72e:	c7 43 48 02 00 00 00 	movl   $0x2,0x48(%rbx)
	wr->num_sge = 1;
     735:	c7 43 40 01 00 00 00 	movl   $0x1,0x40(%rbx)
	sgl->lkey = rdma_pd->local_dma_lkey;
     73c:	89 43 24             	mov    %eax,0x24(%rbx)
	sgl = &sw->sgl;
     73f:	48 8d 43 18          	lea    0x18(%rbx),%rax
	wr->wr_id = (uint64_t) sw;
     743:	48 89 5b 30          	mov    %rbx,0x30(%rbx)
	wr->next = NULL;
     747:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
     74e:	00 
	sgl = &sw->sgl;
     74f:	48 89 43 38          	mov    %rax,0x38(%rbx)
     753:	48 8b 07             	mov    (%rdi),%rax
     756:	48 8b 40 08          	mov    0x8(%rax),%rax
     75a:	e8 00 00 00 00       	callq  75f <__send_dma_addr+0x18f>
	if (ret || bad_wr) {
     75f:	85 c0                	test   %eax,%eax
     761:	89 c3                	mov    %eax,%ebx
     763:	75 2e                	jne    793 <__send_dma_addr+0x1c3>
     765:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
     76a:	75 27                	jne    793 <__send_dma_addr+0x1c3>
}
     76c:	48 83 c4 08          	add    $0x8,%rsp
     770:	89 d8                	mov    %ebx,%eax
     772:	5b                   	pop    %rbx
     773:	41 5c                	pop    %r12
     775:	41 5d                	pop    %r13
     777:	41 5e                	pop    %r14
     779:	41 5f                	pop    %r15
     77b:	5d                   	pop    %rbp
     77c:	c3                   	retq   
		return -ENOMEM;
     77d:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
     782:	eb e8                	jmp    76c <__send_dma_addr+0x19c>
		return -ENOMEM;
     784:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
	kfree(rp);
     789:	4c 89 ef             	mov    %r13,%rdi
     78c:	e8 00 00 00 00       	callq  791 <__send_dma_addr+0x1c1>
	return ret;
     791:	eb d9                	jmp    76c <__send_dma_addr+0x19c>
		printk("Cannot post send wr, %d %p\n", ret, bad_wr);
     793:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
     797:	89 de                	mov    %ebx,%esi
     799:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     7a0:	e8 00 00 00 00       	callq  7a5 <__send_dma_addr+0x1d5>
			ret = -EINVAL;
     7a5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
     7aa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}

static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
		size_t size, enum dma_data_direction dir, unsigned long attrs)
{
	return dma_unmap_page_attrs(dev, addr, size, dir, attrs);
     7af:	b9 01 00 00 00       	mov    $0x1,%ecx
     7b4:	ba 18 00 00 00       	mov    $0x18,%edx
     7b9:	4c 89 f6             	mov    %r14,%rsi
     7bc:	0f 45 d8             	cmovne %eax,%ebx
	ib_dma_unmap_single(rh->device, dma_addr, sizeof(struct pool_info), DMA_TO_DEVICE); 
     7bf:	49 8b 84 24 30 01 00 	mov    0x130(%r12),%rax
     7c6:	00 
     7c7:	48 8b 38             	mov    (%rax),%rdi
     7ca:	e8 c1 fd ff ff       	callq  590 <dma_unmap_page_attrs.constprop.31>
     7cf:	eb b8                	jmp    789 <__send_dma_addr+0x1b9>
     7d1:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 7d8 <__send_dma_addr+0x208>
     7d8:	e9 a5 fe ff ff       	jmpq   682 <__send_dma_addr+0xb2>
     7dd:	0f 1f 00             	nopl   (%rax)

00000000000007e0 <__setup_dma_buffer>:
{
     7e0:	e8 00 00 00 00       	callq  7e5 <__setup_dma_buffer+0x5>
     7e5:	55                   	push   %rbp
	struct ib_reg_wr reg_wr = {
     7e6:	31 c0                	xor    %eax,%eax
     7e8:	b9 06 00 00 00       	mov    $0x6,%ecx
	return kmalloc_order_trace(size, flags, order);
     7ed:	ba 09 00 00 00       	mov    $0x9,%edx
     7f2:	be c0 0c 00 00       	mov    $0xcc0,%esi
{
     7f7:	48 89 e5             	mov    %rsp,%rbp
     7fa:	41 57                	push   %r15
     7fc:	41 56                	push   %r14
     7fe:	41 55                	push   %r13
     800:	41 54                	push   %r12
     802:	49 89 fc             	mov    %rdi,%r12
     805:	53                   	push   %rbx
	struct ib_reg_wr reg_wr = {
     806:	48 8d 5d a0          	lea    -0x60(%rbp),%rbx
     80a:	48 89 df             	mov    %rbx,%rdi
{
     80d:	48 83 ec 60          	sub    $0x60,%rsp
	const struct ib_send_wr *bad_wr = NULL;
     811:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
     818:	00 00 00 00 
	struct ib_reg_wr reg_wr = {
     81c:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	struct scatterlist sg = {};
     81f:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
     826:	00 
	struct ib_reg_wr reg_wr = {
     827:	c7 45 bc 20 00 00 00 	movl   $0x20,-0x44(%rbp)
     82e:	c7 45 c0 02 00 00 00 	movl   $0x2,-0x40(%rbp)
	struct scatterlist sg = {};
     835:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
     83c:	00 
     83d:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
     844:	00 
     845:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
     84c:	00 
	struct ib_reg_wr reg_wr = {
     84d:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
     853:	bf 00 10 10 00       	mov    $0x101000,%edi
     858:	c7 45 d4 03 00 00 00 	movl   $0x3,-0x2c(%rbp)
     85f:	e8 00 00 00 00       	callq  864 <__setup_dma_buffer+0x84>
	if (!rh->dma_buffer) {
     864:	48 85 c0             	test   %rax,%rax
	rh->dma_buffer = kmalloc(buffer_size, GFP_KERNEL);
     867:	49 89 44 24 40       	mov    %rax,0x40(%r12)
	if (!rh->dma_buffer) {
     86c:	0f 84 ad 01 00 00    	je     a1f <__setup_dma_buffer+0x23f>
	dma_addr = ib_dma_map_single(rh->device, rh->dma_buffer,
     872:	49 8b 94 24 30 01 00 	mov    0x130(%r12),%rdx
     879:	00 
     87a:	be 00 00 00 80       	mov    $0x80000000,%esi
     87f:	48 01 f0             	add    %rsi,%rax
     882:	48 8b 3a             	mov    (%rdx),%rdi
     885:	0f 82 d4 01 00 00    	jb     a5f <__setup_dma_buffer+0x27f>
     88b:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
     892:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 899 <__setup_dma_buffer+0xb9>
     899:	48 01 c6             	add    %rax,%rsi
	return dma_map_page_attrs(dev, virt_to_page(ptr), offset_in_page(ptr),
     89c:	48 c1 ee 0c          	shr    $0xc,%rsi
     8a0:	48 c1 e6 06          	shl    $0x6,%rsi
     8a4:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 8ab <__setup_dma_buffer+0xcb>
	if (dev && dev->dma_ops)
     8ab:	48 85 ff             	test   %rdi,%rdi
     8ae:	74 27                	je     8d7 <__setup_dma_buffer+0xf7>
     8b0:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
     8b7:	48 85 c0             	test   %rax,%rax
     8ba:	74 1b                	je     8d7 <__setup_dma_buffer+0xf7>
		addr = ops->map_page(dev, page, offset, size, dir, attrs);
     8bc:	48 8b 40 20          	mov    0x20(%rax),%rax
     8c0:	45 31 c9             	xor    %r9d,%r9d
     8c3:	45 31 c0             	xor    %r8d,%r8d
     8c6:	b9 00 10 10 00       	mov    $0x101000,%ecx
     8cb:	31 d2                	xor    %edx,%edx
     8cd:	e8 00 00 00 00       	callq  8d2 <__setup_dma_buffer+0xf2>
     8d2:	49 89 c5             	mov    %rax,%r13
     8d5:	eb 21                	jmp    8f8 <__setup_dma_buffer+0x118>
     8d7:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 8de <__setup_dma_buffer+0xfe>
	if (dma_is_direct(ops))
     8de:	48 85 c0             	test   %rax,%rax
     8e1:	75 d9                	jne    8bc <__setup_dma_buffer+0xdc>
		addr = dma_direct_map_page(dev, page, offset, size, dir, attrs);
     8e3:	45 31 c9             	xor    %r9d,%r9d
     8e6:	45 31 c0             	xor    %r8d,%r8d
     8e9:	b9 00 10 10 00       	mov    $0x101000,%ecx
     8ee:	31 d2                	xor    %edx,%edx
     8f0:	e8 00 00 00 00       	callq  8f5 <__setup_dma_buffer+0x115>
     8f5:	49 89 c5             	mov    %rax,%r13
	if (dma_addr == DMA_MAPPING_ERROR)
     8f8:	49 83 fd ff          	cmp    $0xffffffffffffffff,%r13
     8fc:	0f 84 69 01 00 00    	je     a6b <__setup_dma_buffer+0x28b>
	mr = ib_alloc_mr(rdma_pd, IB_MR_TYPE_MEM_REG, buffer_size / PAGE_SIZE);
     902:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 909 <__setup_dma_buffer+0x129>
     909:	31 f6                	xor    %esi,%esi
     90b:	ba 01 01 00 00       	mov    $0x101,%edx
     910:	e8 00 00 00 00       	callq  915 <__setup_dma_buffer+0x135>
	if (IS_ERR(mr)) {
     915:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
	mr = ib_alloc_mr(rdma_pd, IB_MR_TYPE_MEM_REG, buffer_size / PAGE_SIZE);
     91b:	49 89 c6             	mov    %rax,%r14
	if (IS_ERR(mr)) {
     91e:	0f 87 d1 00 00 00    	ja     9f5 <__setup_dma_buffer+0x215>
	ret = ib_map_mr_sg(mr, &sg, 1, NULL, buffer_size);
     924:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
     928:	31 c9                	xor    %ecx,%ecx
     92a:	41 b8 00 10 10 00    	mov    $0x101000,%r8d
     930:	ba 01 00 00 00       	mov    $0x1,%edx
     935:	48 89 c7             	mov    %rax,%rdi
	sg_dma_address(&sg) = dma_addr;
     938:	4c 89 6d 90          	mov    %r13,-0x70(%rbp)
	sg_dma_len(&sg) = buffer_size;
     93c:	c7 45 98 00 10 10 00 	movl   $0x101000,-0x68(%rbp)
	ret = ib_map_mr_sg(mr, &sg, 1, NULL, buffer_size);
     943:	e8 00 00 00 00       	callq  948 <__setup_dma_buffer+0x168>
	if (ret != 1) {
     948:	83 f8 01             	cmp    $0x1,%eax
	ret = ib_map_mr_sg(mr, &sg, 1, NULL, buffer_size);
     94b:	41 89 c7             	mov    %eax,%r15d
	if (ret != 1) {
     94e:	0f 85 26 01 00 00    	jne    a7a <__setup_dma_buffer+0x29a>
	reg_wr.mr = mr;
     954:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
	ret = ib_post_send(rh->qp, &reg_wr.wr, &bad_wr);
     958:	49 8b bc 24 40 01 00 	mov    0x140(%r12),%rdi
     95f:	00 
     960:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
	reg_wr.key = mr->rkey;
     967:	41 8b 46 14          	mov    0x14(%r14),%eax
     96b:	48 89 de             	mov    %rbx,%rsi
     96e:	89 45 d0             	mov    %eax,-0x30(%rbp)
     971:	48 8b 07             	mov    (%rdi),%rax
     974:	48 8b 40 08          	mov    0x8(%rax),%rax
     978:	e8 00 00 00 00       	callq  97d <__setup_dma_buffer+0x19d>
	if (ret || bad_wr) {
     97d:	85 c0                	test   %eax,%eax
     97f:	41 89 c7             	mov    %eax,%r15d
     982:	0f 85 9f 00 00 00    	jne    a27 <__setup_dma_buffer+0x247>
     988:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
     98f:	00 
     990:	0f 85 91 00 00 00    	jne    a27 <__setup_dma_buffer+0x247>
	rh->rpc_buffer = rh->dma_buffer;
     996:	49 8b 44 24 40       	mov    0x40(%r12),%rax
	rh->dma_addr = dma_addr;
     99b:	4d 89 6c 24 68       	mov    %r13,0x68(%r12)
	rh->mr = mr;
     9a0:	4d 89 b4 24 48 01 00 	mov    %r14,0x148(%r12)
     9a7:	00 
	rh->rpc_dma_addr = rh->dma_addr;
     9a8:	4d 89 6c 24 70       	mov    %r13,0x70(%r12)
	rh->rpc_buffer_size = RPC_BUFFER_SIZE;
     9ad:	49 c7 84 24 a8 00 00 	movq   $0x1000,0xa8(%r12)
     9b4:	00 00 10 00 00 
	rh->evict_dma_addr = rh->dma_addr;
     9b9:	4d 89 ac 24 80 00 00 	mov    %r13,0x80(%r12)
     9c0:	00 
	rh->sink_buffer = (void *) ((uint8_t *) rh->dma_buffer) + RPC_BUFFER_SIZE;
     9c1:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
	rh->rpc_buffer = rh->dma_buffer;
     9c8:	49 89 44 24 48       	mov    %rax,0x48(%r12)
	rh->evict_buffer = rh->dma_buffer;
     9cd:	49 89 44 24 58       	mov    %rax,0x58(%r12)
	rh->sink_buffer = (void *) ((uint8_t *) rh->dma_buffer) + RPC_BUFFER_SIZE;
     9d2:	49 89 54 24 50       	mov    %rdx,0x50(%r12)
	rh->sink_dma_addr = rh->dma_addr + RPC_BUFFER_SIZE;
     9d7:	49 8d 95 00 10 00 00 	lea    0x1000(%r13),%rdx
     9de:	49 89 54 24 78       	mov    %rdx,0x78(%r12)
}
     9e3:	48 83 c4 60          	add    $0x60,%rsp
     9e7:	44 89 f8             	mov    %r15d,%eax
     9ea:	5b                   	pop    %rbx
     9eb:	41 5c                	pop    %r12
     9ed:	41 5d                	pop    %r13
     9ef:	41 5e                	pop    %r14
     9f1:	41 5f                	pop    %r15
     9f3:	5d                   	pop    %rbp
     9f4:	c3                   	retq   
		ret = PTR_ERR(mr);
     9f5:	41 89 c7             	mov    %eax,%r15d
	step = "alloc mr";
     9f8:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
	if (rh->dma_buffer)
     9ff:	49 8b 7c 24 40       	mov    0x40(%r12),%rdi
     a04:	48 85 ff             	test   %rdi,%rdi
     a07:	74 05                	je     a0e <__setup_dma_buffer+0x22e>
		kfree(rh->dma_buffer);
     a09:	e8 00 00 00 00       	callq  a0e <__setup_dma_buffer+0x22e>
	printk(KERN_ERR PFX "fail at %s\n", step);
     a0e:	48 89 de             	mov    %rbx,%rsi
     a11:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     a18:	e8 00 00 00 00       	callq  a1d <__setup_dma_buffer+0x23d>
	return ret;
     a1d:	eb c4                	jmp    9e3 <__setup_dma_buffer+0x203>
		return -ENOMEM;
     a1f:	41 bf f4 ff ff ff    	mov    $0xfffffff4,%r15d
     a25:	eb bc                	jmp    9e3 <__setup_dma_buffer+0x203>
		printk(PFX "Cannot register mr, %d %p\n", ret, bad_wr);
     a27:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
     a2e:	44 89 fe             	mov    %r15d,%esi
     a31:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	step = "post reg mr";
     a38:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
		printk(PFX "Cannot register mr, %d %p\n", ret, bad_wr);
     a3f:	e8 00 00 00 00       	callq  a44 <__setup_dma_buffer+0x264>
	step = "post reg mr";
     a44:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
     a4b:	00 
     a4c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
     a51:	44 0f 45 f8          	cmovne %eax,%r15d
	ib_dereg_mr(mr);
     a55:	4c 89 f7             	mov    %r14,%rdi
     a58:	e8 00 00 00 00       	callq  a5d <__setup_dma_buffer+0x27d>
     a5d:	eb a0                	jmp    9ff <__setup_dma_buffer+0x21f>
     a5f:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # a66 <__setup_dma_buffer+0x286>
     a66:	e9 2e fe ff ff       	jmpq   899 <__setup_dma_buffer+0xb9>
	step = "alloc dma buffer";
     a6b:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
		return -ENOMEM;
     a72:	41 bf f4 ff ff ff    	mov    $0xfffffff4,%r15d
     a78:	eb 85                	jmp    9ff <__setup_dma_buffer+0x21f>
		printk(PFX "Cannot map scatterlist to mr, %d\n", ret);
     a7a:	89 c6                	mov    %eax,%esi
     a7c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	step = "map mr";
     a83:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
		printk(PFX "Cannot map scatterlist to mr, %d\n", ret);
     a8a:	e8 00 00 00 00       	callq  a8f <__setup_dma_buffer+0x2af>
		goto out_dereg;
     a8f:	eb c4                	jmp    a55 <__setup_dma_buffer+0x275>
     a91:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     a96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     a9d:	00 00 00 

0000000000000aa0 <__refill_rdma_work.constprop.28>:
static int __refill_rdma_work(struct rdma_handle *rh, int nr_works)
     aa0:	e8 00 00 00 00       	callq  aa5 <__refill_rdma_work.constprop.28+0x5>
     aa5:	55                   	push   %rbp
     aa6:	ba 04 00 00 00       	mov    $0x4,%edx
     aab:	be c0 0d 00 00       	mov    $0xdc0,%esi
     ab0:	48 89 e5             	mov    %rsp,%rbp
     ab3:	41 57                	push   %r15
     ab5:	41 56                	push   %r14
     ab7:	41 55                	push   %r13
     ab9:	41 54                	push   %r12
     abb:	49 89 fe             	mov    %rdi,%r14
     abe:	53                   	push   %rbx
     abf:	bf 00 88 00 00       	mov    $0x8800,%edi
     ac4:	e8 00 00 00 00       	callq  ac9 <__refill_rdma_work.constprop.28+0x29>
	if (!rh->rdma_work_pool)
     ac9:	48 85 c0             	test   %rax,%rax
	rh->rdma_work_pool = kzalloc(sizeof(struct rdma_work) * nr_works, GFP_KERNEL);
     acc:	49 89 86 90 00 00 00 	mov    %rax,0x90(%r14)
	if (!rh->rdma_work_pool)
     ad3:	0f 84 d8 00 00 00    	je     bb1 <__refill_rdma_work.constprop.28+0x111>
		rw->sgl.lkey = rdma_pd->local_dma_lkey;
     ad9:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # ae0 <__refill_rdma_work.constprop.28+0x40>
     ae0:	31 d2                	xor    %edx,%edx
	struct rdma_work *work_list = NULL;
     ae2:	31 c9                	xor    %ecx,%ecx
	struct rdma_work *last_work = NULL;
     ae4:	45 31 ed             	xor    %r13d,%r13d
	for (i = 0; i < nr_works; i++) {
     ae7:	45 31 e4             	xor    %r12d,%r12d
     aea:	eb 0a                	jmp    af6 <__refill_rdma_work.constprop.28+0x56>
     aec:	49 8b 86 90 00 00 00 	mov    0x90(%r14),%rax
		struct rdma_work *rw = &rh->rdma_work_pool[i];
     af3:	48 89 d9             	mov    %rbx,%rcx
     af6:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
     afa:	4d 85 ed             	test   %r13,%r13
		rw->id = i;
     afd:	44 88 23             	mov    %r12b,(%rbx)
		rw->work_type = WORK_TYPE_RPC;
     b00:	c7 43 04 05 00 00 00 	movl   $0x5,0x4(%rbx)
		struct rdma_work *rw = &rh->rdma_work_pool[i];
     b07:	4c 0f 44 eb          	cmove  %rbx,%r13
		rw->sgl.addr = 0;
     b0b:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
     b12:	00 
		rw->sgl.length = 0;
     b13:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%rbx)
		nr_refilled++;
     b1a:	41 83 c4 01          	add    $0x1,%r12d
		rw->sgl.lkey = rdma_pd->local_dma_lkey;
     b1e:	8b 06                	mov    (%rsi),%eax
     b20:	48 81 c2 88 00 00 00 	add    $0x88,%rdx
	for (i = 0; i < nr_works; i++) {
     b27:	41 81 fc 00 01 00 00 	cmp    $0x100,%r12d
		rw->wr.wr.next = NULL;
     b2e:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
     b35:	00 
		rw->wr.wr.wr_id = (u64)rw;
     b36:	48 89 5b 30          	mov    %rbx,0x30(%rbx)
		rw->wr.wr.num_sge = 1;
     b3a:	c7 43 40 01 00 00 00 	movl   $0x1,0x40(%rbx)
		rw->wr.wr.opcode = IB_WR_RDMA_WRITE_WITH_IMM; // IB_WR_RDMA_WRITE_WITH_IMM;
     b41:	c7 43 44 01 00 00 00 	movl   $0x1,0x44(%rbx)
		rw->sgl.lkey = rdma_pd->local_dma_lkey;
     b48:	89 43 24             	mov    %eax,0x24(%rbx)
		rw->wr.wr.sg_list = &rw->sgl;
     b4b:	48 8d 43 18          	lea    0x18(%rbx),%rax
		rw->wr.wr.send_flags = IB_SEND_SIGNALED;
     b4f:	c7 43 48 02 00 00 00 	movl   $0x2,0x48(%rbx)
		rw->wr.remote_addr = 0;
     b56:	48 c7 43 50 00 00 00 	movq   $0x0,0x50(%rbx)
     b5d:	00 
		rw->wr.rkey = 0;
     b5e:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%rbx)
		rw->wr.wr.sg_list = &rw->sgl;
     b65:	48 89 43 38          	mov    %rax,0x38(%rbx)
		rw->next = work_list;
     b69:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
	for (i = 0; i < nr_works; i++) {
     b6d:	0f 85 79 ff ff ff    	jne    aec <__refill_rdma_work.constprop.28+0x4c>
     b73:	4d 8d be 98 00 00 00 	lea    0x98(%r14),%r15
     b7a:	4c 89 ff             	mov    %r15,%rdi
     b7d:	e8 00 00 00 00       	callq  b82 <__refill_rdma_work.constprop.28+0xe2>
	if (work_list) {
     b82:	48 85 db             	test   %rbx,%rbx
     b85:	74 12                	je     b99 <__refill_rdma_work.constprop.28+0xf9>
		last_work->next = rh->rdma_work_head;
     b87:	49 8b 86 88 00 00 00 	mov    0x88(%r14),%rax
     b8e:	49 89 45 10          	mov    %rax,0x10(%r13)
		rh->rdma_work_head = work_list;
     b92:	49 89 9e 88 00 00 00 	mov    %rbx,0x88(%r14)
     b99:	4c 89 ff             	mov    %r15,%rdi
     b9c:	ff 14 25 00 00 00 00 	callq  *0x0
}
     ba3:	5b                   	pop    %rbx
     ba4:	44 89 e0             	mov    %r12d,%eax
     ba7:	41 5c                	pop    %r12
     ba9:	41 5d                	pop    %r13
     bab:	41 5e                	pop    %r14
     bad:	41 5f                	pop    %r15
     baf:	5d                   	pop    %rbp
     bb0:	c3                   	retq   
		return -ENOMEM;
     bb1:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
     bb7:	eb ea                	jmp    ba3 <__refill_rdma_work.constprop.28+0x103>
     bb9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000000bc0 <__setup_recv_addr>:
{
     bc0:	e8 00 00 00 00       	callq  bc5 <__setup_recv_addr+0x5>
     bc5:	55                   	push   %rbp
     bc6:	48 89 e5             	mov    %rsp,%rbp
     bc9:	41 57                	push   %r15
     bcb:	41 56                	push   %r14
     bcd:	41 55                	push   %r13
     bcf:	41 54                	push   %r12
     bd1:	49 89 fe             	mov    %rdi,%r14
     bd4:	53                   	push   %rbx
     bd5:	41 89 f4             	mov    %esi,%r12d
     bd8:	48 83 ec 20          	sub    $0x20,%rsp
	if (work_type == WORK_TYPE_RPC_ADDR) {
     bdc:	83 fe 01             	cmp    $0x1,%esi
	const struct ib_recv_wr *bad_wr = NULL;
     bdf:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
     be6:	00 
	struct ib_sge sgl = {0};
     be7:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
     bee:	00 
     bef:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
     bf6:	00 
     bf7:	8b 57 30             	mov    0x30(%rdi),%edx
     bfa:	48 63 07             	movslq (%rdi),%rax
	if (work_type == WORK_TYPE_RPC_ADDR) {
     bfd:	0f 84 d5 01 00 00    	je     dd8 <__setup_recv_addr+0x218>
		if (rh->connection_type == CONNECTION_FETCH)
     c03:	85 d2                	test   %edx,%edx
     c05:	0f 84 5f 01 00 00    	je     d6a <__setup_recv_addr+0x1aa>
			pp = sink_pools_evic[rh->nid];
     c0b:	48 8b 1c c5 00 00 00 	mov    0x0(,%rax,8),%rbx
     c12:	00 
		return kmem_cache_alloc_trace(
     c13:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # c1a <__setup_recv_addr+0x5a>
     c1a:	ba 50 00 00 00       	mov    $0x50,%edx
     c1f:	be c0 0c 00 00       	mov    $0xcc0,%esi
     c24:	e8 00 00 00 00       	callq  c29 <__setup_recv_addr+0x69>
	if (!rw)
     c29:	48 85 c0             	test   %rax,%rax
     c2c:	49 89 c5             	mov    %rax,%r13
     c2f:	0f 84 cb 01 00 00    	je     e00 <__setup_recv_addr+0x240>
	dma_addr = ib_dma_map_single(rh->device, pp, sizeof(struct pool_info), DMA_FROM_DEVICE);
     c35:	49 8b 86 30 01 00 00 	mov    0x130(%r14),%rax
	return dma_map_page_attrs(dev, virt_to_page(ptr), offset_in_page(ptr),
     c3c:	48 89 da             	mov    %rbx,%rdx
     c3f:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
     c45:	48 8b 38             	mov    (%rax),%rdi
     c48:	b8 00 00 00 80       	mov    $0x80000000,%eax
     c4d:	48 01 d8             	add    %rbx,%rax
     c50:	0f 82 b4 01 00 00    	jb     e0a <__setup_recv_addr+0x24a>
     c56:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
     c5d:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # c64 <__setup_recv_addr+0xa4>
     c64:	48 01 c6             	add    %rax,%rsi
     c67:	48 c1 ee 0c          	shr    $0xc,%rsi
     c6b:	48 c1 e6 06          	shl    $0x6,%rsi
     c6f:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # c76 <__setup_recv_addr+0xb6>
	if (dev && dev->dma_ops)
     c76:	48 85 ff             	test   %rdi,%rdi
     c79:	0f 84 f8 00 00 00    	je     d77 <__setup_recv_addr+0x1b7>
     c7f:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
     c86:	48 85 c0             	test   %rax,%rax
     c89:	0f 84 e8 00 00 00    	je     d77 <__setup_recv_addr+0x1b7>
		addr = ops->map_page(dev, page, offset, size, dir, attrs);
     c8f:	48 8b 40 20          	mov    0x20(%rax),%rax
     c93:	45 31 c9             	xor    %r9d,%r9d
     c96:	41 b8 02 00 00 00    	mov    $0x2,%r8d
     c9c:	b9 18 00 00 00       	mov    $0x18,%ecx
     ca1:	e8 00 00 00 00       	callq  ca6 <__setup_recv_addr+0xe6>
     ca6:	49 89 c7             	mov    %rax,%r15
	if (dma_addr == DMA_MAPPING_ERROR)
     ca9:	49 83 ff ff          	cmp    $0xffffffffffffffff,%r15
     cad:	0f 84 43 01 00 00    	je     df6 <__setup_recv_addr+0x236>
	sgl.lkey = rdma_pd->local_dma_lkey;
     cb3:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # cba <__setup_recv_addr+0xfa>
	rw->work_type = work_type; 
     cba:	45 89 65 00          	mov    %r12d,0x0(%r13)
	wr = &rw->wr;
     cbe:	49 8d 75 20          	lea    0x20(%r13),%rsi
	rw->dma_addr = dma_addr;
     cc2:	4d 89 7d 40          	mov    %r15,0x40(%r13)
	rw->addr = pp;
     cc6:	49 89 5d 48          	mov    %rbx,0x48(%r13)
	return qp->device->ops.post_recv(qp, recv_wr, bad_recv_wr ? : &dummy);
     cca:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
	rw->rh = rh;
     cce:	4d 89 75 08          	mov    %r14,0x8(%r13)
	ret = ib_post_recv(rh->qp, wr, &bad_wr);
     cd2:	49 8b be 40 01 00 00 	mov    0x140(%r14),%rdi
	sgl.lkey = rdma_pd->local_dma_lkey;
     cd9:	8b 00                	mov    (%rax),%eax
	wr->num_sge = 1;
     cdb:	41 c7 45 38 01 00 00 	movl   $0x1,0x38(%r13)
     ce2:	00 
	wr->next = NULL;
     ce3:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
     cea:	00 
	wr->wr_id = (u64) rw; 
     ceb:	4d 89 6d 28          	mov    %r13,0x28(%r13)
	sgl.addr = dma_addr;
     cef:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
	sgl.length = sizeof(struct pool_info);
     cf3:	c7 45 d0 18 00 00 00 	movl   $0x18,-0x30(%rbp)
	sgl.lkey = rdma_pd->local_dma_lkey;
     cfa:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	wr->sg_list = &sgl;
     cfd:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
     d01:	49 89 45 30          	mov    %rax,0x30(%r13)
     d05:	48 8b 07             	mov    (%rdi),%rax
     d08:	48 8b 40 10          	mov    0x10(%rax),%rax
     d0c:	e8 00 00 00 00       	callq  d11 <__setup_recv_addr+0x151>
	if (ret || bad_wr) 
     d11:	85 c0                	test   %eax,%eax
     d13:	75 07                	jne    d1c <__setup_recv_addr+0x15c>
     d15:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
     d1a:	74 3f                	je     d5b <__setup_recv_addr+0x19b>
	ib_dma_unmap_single(rh->device, dma_addr, sizeof(struct pool_info), DMA_FROM_DEVICE);
     d1c:	49 8b 96 30 01 00 00 	mov    0x130(%r14),%rdx
     d23:	48 8b 3a             	mov    (%rdx),%rdi
	if (dev && dev->dma_ops)
     d26:	48 85 ff             	test   %rdi,%rdi
     d29:	74 77                	je     da2 <__setup_recv_addr+0x1e2>
     d2b:	48 8b 97 28 02 00 00 	mov    0x228(%rdi),%rdx
     d32:	48 85 d2             	test   %rdx,%rdx
     d35:	74 6b                	je     da2 <__setup_recv_addr+0x1e2>
	else if (ops->unmap_page)
     d37:	4c 8b 4a 28          	mov    0x28(%rdx),%r9
     d3b:	4d 85 c9             	test   %r9,%r9
     d3e:	74 1b                	je     d5b <__setup_recv_addr+0x19b>
     d40:	89 45 bc             	mov    %eax,-0x44(%rbp)
		ops->unmap_page(dev, addr, size, dir, attrs);
     d43:	45 31 c0             	xor    %r8d,%r8d
     d46:	b9 02 00 00 00       	mov    $0x2,%ecx
     d4b:	ba 18 00 00 00       	mov    $0x18,%edx
     d50:	4c 89 fe             	mov    %r15,%rsi
     d53:	e8 00 00 00 00       	callq  d58 <__setup_recv_addr+0x198>
     d58:	8b 45 bc             	mov    -0x44(%rbp),%eax
}
     d5b:	48 83 c4 20          	add    $0x20,%rsp
     d5f:	5b                   	pop    %rbx
     d60:	41 5c                	pop    %r12
     d62:	41 5d                	pop    %r13
     d64:	41 5e                	pop    %r14
     d66:	41 5f                	pop    %r15
     d68:	5d                   	pop    %rbp
     d69:	c3                   	retq   
			pp = sink_pools[rh->nid];
     d6a:	48 8b 1c c5 00 00 00 	mov    0x0(,%rax,8),%rbx
     d71:	00 
     d72:	e9 9c fe ff ff       	jmpq   c13 <__setup_recv_addr+0x53>
     d77:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # d7e <__setup_recv_addr+0x1be>
	if (dma_is_direct(ops))
     d7e:	48 85 c0             	test   %rax,%rax
     d81:	0f 85 08 ff ff ff    	jne    c8f <__setup_recv_addr+0xcf>
		addr = dma_direct_map_page(dev, page, offset, size, dir, attrs);
     d87:	45 31 c9             	xor    %r9d,%r9d
     d8a:	41 b8 02 00 00 00    	mov    $0x2,%r8d
     d90:	b9 18 00 00 00       	mov    $0x18,%ecx
     d95:	e8 00 00 00 00       	callq  d9a <__setup_recv_addr+0x1da>
     d9a:	49 89 c7             	mov    %rax,%r15
     d9d:	e9 07 ff ff ff       	jmpq   ca9 <__setup_recv_addr+0xe9>
     da2:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # da9 <__setup_recv_addr+0x1e9>
	if (dma_is_direct(ops))
     da9:	48 85 d2             	test   %rdx,%rdx
     dac:	75 89                	jne    d37 <__setup_recv_addr+0x177>
		dma_direct_unmap_page(dev, addr, size, dir, attrs);
     dae:	4c 89 fe             	mov    %r15,%rsi
     db1:	45 31 c0             	xor    %r8d,%r8d
     db4:	b9 02 00 00 00       	mov    $0x2,%ecx
     db9:	ba 18 00 00 00       	mov    $0x18,%edx
     dbe:	89 45 bc             	mov    %eax,-0x44(%rbp)
     dc1:	e8 00 00 00 00       	callq  dc6 <__setup_recv_addr+0x206>
     dc6:	8b 45 bc             	mov    -0x44(%rbp),%eax
}
     dc9:	48 83 c4 20          	add    $0x20,%rsp
     dcd:	5b                   	pop    %rbx
     dce:	41 5c                	pop    %r12
     dd0:	41 5d                	pop    %r13
     dd2:	41 5e                	pop    %r14
     dd4:	41 5f                	pop    %r15
     dd6:	5d                   	pop    %rbp
     dd7:	c3                   	retq   
		if (rh->connection_type == CONNECTION_FETCH)
     dd8:	85 d2                	test   %edx,%edx
     dda:	75 0d                	jne    de9 <__setup_recv_addr+0x229>
			pp = rpc_pools[rh->nid];
     ddc:	48 8b 1c c5 00 00 00 	mov    0x0(,%rax,8),%rbx
     de3:	00 
     de4:	e9 2a fe ff ff       	jmpq   c13 <__setup_recv_addr+0x53>
			pp = rpc_pools_evic[rh->nid];
     de9:	48 8b 1c c5 00 00 00 	mov    0x0(,%rax,8),%rbx
     df0:	00 
     df1:	e9 1d fe ff ff       	jmpq   c13 <__setup_recv_addr+0x53>
		return -ENOMEM;
     df6:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
     dfb:	e9 1c ff ff ff       	jmpq   d1c <__setup_recv_addr+0x15c>
		return -ENOMEM;
     e00:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
     e05:	e9 51 ff ff ff       	jmpq   d5b <__setup_recv_addr+0x19b>
     e0a:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # e11 <__setup_recv_addr+0x251>
     e11:	e9 4e fe ff ff       	jmpq   c64 <__setup_recv_addr+0xa4>
     e16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     e1d:	00 00 00 

0000000000000e20 <__setup_recv_works>:
{
     e20:	e8 00 00 00 00       	callq  e25 <__setup_recv_works+0x5>
     e25:	55                   	push   %rbp
	ret = __setup_recv_addr(rh, WORK_TYPE_RPC_ADDR);
     e26:	be 01 00 00 00       	mov    $0x1,%esi
{
     e2b:	48 89 e5             	mov    %rsp,%rbp
     e2e:	41 57                	push   %r15
     e30:	41 56                	push   %r14
     e32:	41 55                	push   %r13
     e34:	41 54                	push   %r12
     e36:	53                   	push   %rbx
     e37:	48 89 fb             	mov    %rdi,%rbx
     e3a:	48 83 ec 20          	sub    $0x20,%rsp
	ret = __setup_recv_addr(rh, WORK_TYPE_RPC_ADDR);
     e3e:	e8 7d fd ff ff       	callq  bc0 <__setup_recv_addr>
	if (ret)
     e43:	85 c0                	test   %eax,%eax
     e45:	74 0f                	je     e56 <__setup_recv_works+0x36>
}
     e47:	48 83 c4 20          	add    $0x20,%rsp
     e4b:	5b                   	pop    %rbx
     e4c:	41 5c                	pop    %r12
     e4e:	41 5d                	pop    %r13
     e50:	41 5e                	pop    %r14
     e52:	41 5f                	pop    %r15
     e54:	5d                   	pop    %rbp
     e55:	c3                   	retq   
	ret = __setup_recv_addr(rh, WORK_TYPE_SINK_ADDR);
     e56:	be 02 00 00 00       	mov    $0x2,%esi
     e5b:	48 89 df             	mov    %rbx,%rdi
     e5e:	e8 5d fd ff ff       	callq  bc0 <__setup_recv_addr>
	if (ret)
     e63:	85 c0                	test   %eax,%eax
     e65:	75 e0                	jne    e47 <__setup_recv_works+0x27>
     e67:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # e6e <__setup_recv_works+0x4e>
     e6e:	ba 00 10 00 00       	mov    $0x1000,%edx
     e73:	be c0 0c 00 00       	mov    $0xcc0,%esi
     e78:	e8 00 00 00 00       	callq  e7d <__setup_recv_works+0x5d>
	if (!recv_buffer) {
     e7d:	48 85 c0             	test   %rax,%rax
     e80:	49 89 c4             	mov    %rax,%r12
     e83:	0f 84 a6 01 00 00    	je     102f <__setup_recv_works+0x20f>
	return kmalloc_order_trace(size, flags, order);
     e89:	ba 05 00 00 00       	mov    $0x5,%edx
     e8e:	be c0 0c 00 00       	mov    $0xcc0,%esi
     e93:	bf 00 40 01 00       	mov    $0x14000,%edi
     e98:	e8 00 00 00 00       	callq  e9d <__setup_recv_works+0x7d>
	if (!rws) {
     e9d:	48 85 c0             	test   %rax,%rax
     ea0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     ea4:	0f 84 7d 01 00 00    	je     1027 <__setup_recv_works+0x207>
	dma_addr = ib_dma_map_single(
     eaa:	48 8b 83 30 01 00 00 	mov    0x130(%rbx),%rax
	return dma_map_page_attrs(dev, virt_to_page(ptr), offset_in_page(ptr),
     eb1:	4c 89 e2             	mov    %r12,%rdx
     eb4:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
     eba:	48 8b 38             	mov    (%rax),%rdi
     ebd:	b8 00 00 00 80       	mov    $0x80000000,%eax
     ec2:	4c 01 e0             	add    %r12,%rax
     ec5:	0f 82 8e 01 00 00    	jb     1059 <__setup_recv_works+0x239>
     ecb:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
     ed2:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # ed9 <__setup_recv_works+0xb9>
     ed9:	48 01 c6             	add    %rax,%rsi
     edc:	48 c1 ee 0c          	shr    $0xc,%rsi
     ee0:	48 c1 e6 06          	shl    $0x6,%rsi
     ee4:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # eeb <__setup_recv_works+0xcb>
	if (dev && dev->dma_ops)
     eeb:	48 85 ff             	test   %rdi,%rdi
     eee:	0f 84 07 01 00 00    	je     ffb <__setup_recv_works+0x1db>
     ef4:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
     efb:	48 85 c0             	test   %rax,%rax
     efe:	0f 84 f7 00 00 00    	je     ffb <__setup_recv_works+0x1db>
		addr = ops->map_page(dev, page, offset, size, dir, attrs);
     f04:	48 8b 40 20          	mov    0x20(%rax),%rax
     f08:	45 31 c9             	xor    %r9d,%r9d
     f0b:	41 b8 02 00 00 00    	mov    $0x2,%r8d
     f11:	b9 00 10 00 00       	mov    $0x1000,%ecx
     f16:	e8 00 00 00 00       	callq  f1b <__setup_recv_works+0xfb>
     f1b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	if (dma_addr == DMA_MAPPING_ERROR)
     f1f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
     f23:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
     f27:	0f 84 0c 01 00 00    	je     1039 <__setup_recv_works+0x219>
     f2d:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
		rw->addr = recv_buffer + IMM_DATA_SIZE * i;
     f31:	4d 89 e5             	mov    %r12,%r13
     f34:	49 89 c6             	mov    %rax,%r14
     f37:	49 29 c5             	sub    %rax,%r13
     f3a:	49 89 cf             	mov    %rcx,%r15
     f3d:	48 81 c1 20 43 01 00 	add    $0x14320,%rcx
     f44:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
     f48:	eb 1d                	jmp    f67 <__setup_recv_works+0x147>
		if (ret || bad_wr) goto out_free;
     f4a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
     f4f:	0f 85 8a 00 00 00    	jne    fdf <__setup_recv_works+0x1bf>
     f55:	49 83 c7 50          	add    $0x50,%r15
     f59:	49 83 c6 04          	add    $0x4,%r14
	for (i = 0; i < MAX_RECV_DEPTH; i++) {
     f5d:	4c 39 7d c8          	cmp    %r15,-0x38(%rbp)
     f61:	0f 84 d9 00 00 00    	je     1040 <__setup_recv_works+0x220>
		rw->addr = recv_buffer + IMM_DATA_SIZE * i;
     f67:	4b 8d 44 35 00       	lea    0x0(%r13,%r14,1),%rax
		rw->work_type = WORK_TYPE_RPC_RECV;
     f6c:	41 c7 07 03 00 00 00 	movl   $0x3,(%r15)
		rw->dma_addr = dma_addr + IMM_DATA_SIZE * i;
     f73:	4d 89 77 40          	mov    %r14,0x40(%r15)
		rw->rh = rh;
     f77:	49 89 5f 08          	mov    %rbx,0x8(%r15)
		const struct ib_recv_wr *bad_wr = NULL;
     f7b:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
     f82:	00 
     f83:	49 8d 77 20          	lea    0x20(%r15),%rsi
		rw->addr = recv_buffer + IMM_DATA_SIZE * i;
     f87:	49 89 47 48          	mov    %rax,0x48(%r15)
		sgl->lkey = rdma_pd->local_dma_lkey;
     f8b:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # f92 <__setup_recv_works+0x172>
     f92:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
		ret = ib_post_recv(rh->qp, wr, &bad_wr);
     f96:	48 8b bb 40 01 00 00 	mov    0x140(%rbx),%rdi
		sgl->lkey = rdma_pd->local_dma_lkey;
     f9d:	8b 00                	mov    (%rax),%eax
		sgl->addr = rw->dma_addr;
     f9f:	4d 89 77 10          	mov    %r14,0x10(%r15)
		sgl->length = IMM_DATA_SIZE;
     fa3:	41 c7 47 18 04 00 00 	movl   $0x4,0x18(%r15)
     faa:	00 
		wr->num_sge = 1;
     fab:	41 c7 47 38 01 00 00 	movl   $0x1,0x38(%r15)
     fb2:	00 
		wr->next = NULL;
     fb3:	49 c7 47 20 00 00 00 	movq   $0x0,0x20(%r15)
     fba:	00 
		wr->wr_id = (u64) rw;
     fbb:	4d 89 7f 28          	mov    %r15,0x28(%r15)
		sgl->lkey = rdma_pd->local_dma_lkey;
     fbf:	41 89 47 1c          	mov    %eax,0x1c(%r15)
		wr->sg_list = sgl;
     fc3:	49 8d 47 10          	lea    0x10(%r15),%rax
     fc7:	49 89 47 30          	mov    %rax,0x30(%r15)
     fcb:	48 8b 07             	mov    (%rdi),%rax
     fce:	48 8b 40 10          	mov    0x10(%rax),%rax
     fd2:	e8 00 00 00 00       	callq  fd7 <__setup_recv_works+0x1b7>
		if (ret || bad_wr) goto out_free;
     fd7:	85 c0                	test   %eax,%eax
     fd9:	0f 84 6b ff ff ff    	je     f4a <__setup_recv_works+0x12a>
	if (recv_buffer) kfree(recv_buffer);
     fdf:	4c 89 e7             	mov    %r12,%rdi
     fe2:	89 45 c8             	mov    %eax,-0x38(%rbp)
     fe5:	e8 00 00 00 00       	callq  fea <__setup_recv_works+0x1ca>
	if (rws) kfree(rws);
     fea:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
     fee:	e8 00 00 00 00       	callq  ff3 <__setup_recv_works+0x1d3>
     ff3:	8b 45 c8             	mov    -0x38(%rbp),%eax
     ff6:	e9 4c fe ff ff       	jmpq   e47 <__setup_recv_works+0x27>
     ffb:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1002 <__setup_recv_works+0x1e2>
	if (dma_is_direct(ops))
    1002:	48 85 c0             	test   %rax,%rax
    1005:	0f 85 f9 fe ff ff    	jne    f04 <__setup_recv_works+0xe4>
		addr = dma_direct_map_page(dev, page, offset, size, dir, attrs);
    100b:	45 31 c9             	xor    %r9d,%r9d
    100e:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    1014:	b9 00 10 00 00       	mov    $0x1000,%ecx
    1019:	e8 00 00 00 00       	callq  101e <__setup_recv_works+0x1fe>
    101e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    1022:	e9 f8 fe ff ff       	jmpq   f1f <__setup_recv_works+0xff>
	if (recv_buffer) kfree(recv_buffer);
    1027:	4c 89 e7             	mov    %r12,%rdi
    102a:	e8 00 00 00 00       	callq  102f <__setup_recv_works+0x20f>
		ret = -ENOMEM;
    102f:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    1034:	e9 0e fe ff ff       	jmpq   e47 <__setup_recv_works+0x27>
		return -ENOMEM;
    1039:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    103e:	eb 9f                	jmp    fdf <__setup_recv_works+0x1bf>
	rh->recv_works = rws;
    1040:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
	rh->recv_buffer = recv_buffer;
    1044:	4c 89 63 38          	mov    %r12,0x38(%rbx)
	rh->recv_works = rws;
    1048:	48 89 4b 28          	mov    %rcx,0x28(%rbx)
	rh->recv_buffer_dma_addr = dma_addr;
    104c:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    1050:	48 89 4b 60          	mov    %rcx,0x60(%rbx)
    1054:	e9 ee fd ff ff       	jmpq   e47 <__setup_recv_works+0x27>
    1059:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 1060 <__setup_recv_works+0x240>
    1060:	e9 74 fe ff ff       	jmpq   ed9 <__setup_recv_works+0xb9>
    1065:	90                   	nop
    1066:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    106d:	00 00 00 

0000000000001070 <__accept_client>:
{
    1070:	e8 00 00 00 00       	callq  1075 <__accept_client+0x5>
    1075:	55                   	push   %rbp
		rh = rdma_handles[nid];
    1076:	48 63 c7             	movslq %edi,%rax
{
    1079:	48 89 e5             	mov    %rsp,%rbp
    107c:	41 55                	push   %r13
    107e:	41 54                	push   %r12
    1080:	53                   	push   %rbx
    1081:	48 83 ec 18          	sub    $0x18,%rsp
	if (connect_type == CONNECTION_FETCH)
    1085:	85 f6                	test   %esi,%esi
	struct rdma_conn_param conn_param = {};
    1087:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    108e:	00 
    108f:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    1096:	00 
    1097:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    109e:	00 
	if (connect_type == CONNECTION_FETCH)
    109f:	0f 85 ea 00 00 00    	jne    118f <__accept_client+0x11f>
		rh = rdma_handles[nid];
    10a5:	4c 8b 24 c5 00 00 00 	mov    0x0(,%rax,8),%r12
    10ac:	00 
	DEBUG_LOG(PFX "accept client %d connect_type %d\n", nid, connect_type);
    10ad:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 10b3 <__accept_client+0x43>
    10b3:	85 c0                	test   %eax,%eax
    10b5:	0f 85 25 01 00 00    	jne    11e0 <__accept_client+0x170>
	ret = wait_for_completion_interruptible(&rh->cm_done);
    10bb:	4d 8d 6c 24 08       	lea    0x8(%r12),%r13
	if (rh->state != RDMA_ROUTE_RESOLVED) return -EINVAL;
    10c0:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	ret = wait_for_completion_interruptible(&rh->cm_done);
    10c5:	4c 89 ef             	mov    %r13,%rdi
    10c8:	e8 00 00 00 00       	callq  10cd <__accept_client+0x5d>
	if (rh->state != RDMA_ROUTE_RESOLVED) return -EINVAL;
    10cd:	41 83 7c 24 04 02    	cmpl   $0x2,0x4(%r12)
    10d3:	0f 85 a9 00 00 00    	jne    1182 <__accept_client+0x112>
	ret = __setup_pd_cq_qp(rh);
    10d9:	4c 89 e7             	mov    %r12,%rdi
    10dc:	e8 5f f1 ff ff       	callq  240 <__setup_pd_cq_qp>
	if (ret) goto out_err;
    10e1:	85 c0                	test   %eax,%eax
	ret = __setup_pd_cq_qp(rh);
    10e3:	89 c3                	mov    %eax,%ebx
	if (ret) goto out_err;
    10e5:	0f 85 ec 00 00 00    	jne    11d7 <__accept_client+0x167>
	ret = __setup_recv_works(rh);
    10eb:	4c 89 e7             	mov    %r12,%rdi
    10ee:	e8 2d fd ff ff       	callq  e20 <__setup_recv_works>
	if (ret)  goto out_err;
    10f3:	85 c0                	test   %eax,%eax
	ret = __setup_recv_works(rh);
    10f5:	89 c3                	mov    %eax,%ebx
	if (ret)  goto out_err;
    10f7:	0f 85 d1 00 00 00    	jne    11ce <__accept_client+0x15e>
	ret = __refill_rdma_work(rh, NR_RPC_SLOTS);
    10fd:	4c 89 e7             	mov    %r12,%rdi
    1100:	e8 9b f9 ff ff       	callq  aa0 <__refill_rdma_work.constprop.28>
	if (ret == 0)  goto out_err;
    1105:	85 c0                	test   %eax,%eax
	ret = __refill_rdma_work(rh, NR_RPC_SLOTS);
    1107:	89 c3                	mov    %eax,%ebx
	if (ret == 0)  goto out_err;
    1109:	0f 84 b6 00 00 00    	je     11c5 <__accept_client+0x155>
	ret = rdma_accept(rh->cm_id, &conn_param);
    110f:	49 8b bc 24 28 01 00 	mov    0x128(%r12),%rdi
    1116:	00 
    1117:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
	rh->state = RDMA_CONNECTING;
    111b:	41 c7 44 24 04 03 00 	movl   $0x3,0x4(%r12)
    1122:	00 00 
	ret = rdma_accept(rh->cm_id, &conn_param);
    1124:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    112b:	e8 00 00 00 00       	callq  1130 <__accept_client+0xc0>
	if (ret)  goto out_err;
    1130:	85 c0                	test   %eax,%eax
	ret = rdma_accept(rh->cm_id, &conn_param);
    1132:	89 c3                	mov    %eax,%ebx
	if (ret)  goto out_err;
    1134:	75 66                	jne    119c <__accept_client+0x12c>
	ret = wait_for_completion_interruptible(&rh->cm_done);
    1136:	4c 89 ef             	mov    %r13,%rdi
    1139:	e8 00 00 00 00       	callq  113e <__accept_client+0xce>
	if (ret)  goto out_err;
    113e:	85 c0                	test   %eax,%eax
	ret = wait_for_completion_interruptible(&rh->cm_done);
    1140:	89 c3                	mov    %eax,%ebx
	if (ret)  goto out_err;
    1142:	75 58                	jne    119c <__accept_client+0x12c>
	ret = __setup_dma_buffer(rh);
    1144:	4c 89 e7             	mov    %r12,%rdi
    1147:	e8 94 f6 ff ff       	callq  7e0 <__setup_dma_buffer>
	if (ret) goto out_err;
    114c:	85 c0                	test   %eax,%eax
	ret = __setup_dma_buffer(rh);
    114e:	89 c3                	mov    %eax,%ebx
	if (ret) goto out_err;
    1150:	75 6a                	jne    11bc <__accept_client+0x14c>
	ret = __send_dma_addr(rh, rh->rpc_dma_addr, RPC_BUFFER_SIZE);
    1152:	49 8b 74 24 70       	mov    0x70(%r12),%rsi
    1157:	ba 00 10 00 00       	mov    $0x1000,%edx
    115c:	4c 89 e7             	mov    %r12,%rdi
    115f:	e8 6c f4 ff ff       	callq  5d0 <__send_dma_addr>
	if (ret)  goto out_err;
    1164:	85 c0                	test   %eax,%eax
	ret = __send_dma_addr(rh, rh->rpc_dma_addr, RPC_BUFFER_SIZE);
    1166:	89 c3                	mov    %eax,%ebx
	if (ret)  goto out_err;
    1168:	75 49                	jne    11b3 <__accept_client+0x143>
	ret = __send_dma_addr(rh, rh->sink_dma_addr, SINK_BUFFER_SIZE);
    116a:	49 8b 74 24 78       	mov    0x78(%r12),%rsi
    116f:	ba 00 00 10 00       	mov    $0x100000,%edx
    1174:	4c 89 e7             	mov    %r12,%rdi
    1177:	e8 54 f4 ff ff       	callq  5d0 <__send_dma_addr>
	if (ret)  goto out_err;
    117c:	85 c0                	test   %eax,%eax
	ret = __send_dma_addr(rh, rh->sink_dma_addr, SINK_BUFFER_SIZE);
    117e:	89 c3                	mov    %eax,%ebx
	if (ret)  goto out_err;
    1180:	75 31                	jne    11b3 <__accept_client+0x143>
}
    1182:	48 83 c4 18          	add    $0x18,%rsp
    1186:	89 d8                	mov    %ebx,%eax
    1188:	5b                   	pop    %rbx
    1189:	41 5c                	pop    %r12
    118b:	41 5d                	pop    %r13
    118d:	5d                   	pop    %rbp
    118e:	c3                   	retq   
		rh = rdma_handles_evic[nid];
    118f:	4c 8b 24 c5 00 00 00 	mov    0x0(,%rax,8),%r12
    1196:	00 
    1197:	e9 11 ff ff ff       	jmpq   10ad <__accept_client+0x3d>
	step = "accept";
    119c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	printk(KERN_ERR PFX "Failed at %s, %d\n", step, ret);
    11a3:	89 da                	mov    %ebx,%edx
    11a5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    11ac:	e8 00 00 00 00       	callq  11b1 <__accept_client+0x141>
	return ret;
    11b1:	eb cf                	jmp    1182 <__accept_client+0x112>
	step = "post send";
    11b3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    11ba:	eb e7                	jmp    11a3 <__accept_client+0x133>
	step = "setup dma buffer";
    11bc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    11c3:	eb de                	jmp    11a3 <__accept_client+0x133>
	step = "setup rdma works";
    11c5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    11cc:	eb d5                	jmp    11a3 <__accept_client+0x133>
	step = "post recv works";
    11ce:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    11d5:	eb cc                	jmp    11a3 <__accept_client+0x133>
	step = "setup pd cq qp";
    11d7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    11de:	eb c3                	jmp    11a3 <__accept_client+0x133>
	DEBUG_LOG(PFX "accept client %d connect_type %d\n", nid, connect_type);
    11e0:	89 f2                	mov    %esi,%edx
    11e2:	89 fe                	mov    %edi,%esi
    11e4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    11eb:	e8 00 00 00 00       	callq  11f0 <__accept_client+0x180>
    11f0:	e9 c6 fe ff ff       	jmpq   10bb <__accept_client+0x4b>
    11f5:	90                   	nop
    11f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    11fd:	00 00 00 

0000000000001200 <accept_client>:
{
    1200:	e8 00 00 00 00       	callq  1205 <accept_client+0x5>
    1205:	55                   	push   %rbp
    1206:	48 89 e5             	mov    %rsp,%rbp
    1209:	41 54                	push   %r12
    120b:	53                   	push   %rbx
	for (num_client = 0; num_client < MAX_NUM_NODES; num_client++) {
    120c:	31 db                	xor    %ebx,%ebx
    120e:	eb 2b                	jmp    123b <accept_client+0x3b>
		if ((ret = __accept_client(num_client, CONNECTION_FETCH))) 
    1210:	31 f6                	xor    %esi,%esi
    1212:	89 df                	mov    %ebx,%edi
    1214:	e8 57 fe ff ff       	callq  1070 <__accept_client>
    1219:	85 c0                	test   %eax,%eax
    121b:	41 89 c4             	mov    %eax,%r12d
    121e:	75 27                	jne    1247 <accept_client+0x47>
		if ((ret = __accept_client(num_client, CONNECTION_EVICT))) 
    1220:	be 01 00 00 00       	mov    $0x1,%esi
    1225:	89 df                	mov    %ebx,%edi
    1227:	e8 44 fe ff ff       	callq  1070 <__accept_client>
    122c:	85 c0                	test   %eax,%eax
    122e:	41 89 c4             	mov    %eax,%r12d
    1231:	75 14                	jne    1247 <accept_client+0x47>
	for (num_client = 0; num_client < MAX_NUM_NODES; num_client++) {
    1233:	83 c3 01             	add    $0x1,%ebx
    1236:	83 fb 20             	cmp    $0x20,%ebx
    1239:	74 14                	je     124f <accept_client+0x4f>
		if (kthread_should_stop())
    123b:	e8 00 00 00 00       	callq  1240 <accept_client+0x40>
    1240:	84 c0                	test   %al,%al
    1242:	74 cc                	je     1210 <accept_client+0x10>
			return 0;
    1244:	45 31 e4             	xor    %r12d,%r12d
}
    1247:	44 89 e0             	mov    %r12d,%eax
    124a:	5b                   	pop    %rbx
    124b:	41 5c                	pop    %r12
    124d:	5d                   	pop    %rbp
    124e:	c3                   	retq   
	printk(KERN_INFO PFX "Cannot accepts more clients\n");
    124f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1256:	e8 00 00 00 00       	callq  125b <accept_client+0x5b>
}
    125b:	44 89 e0             	mov    %r12d,%eax
    125e:	5b                   	pop    %rbx
    125f:	41 5c                	pop    %r12
    1261:	5d                   	pop    %rbp
    1262:	c3                   	retq   
    1263:	0f 1f 00             	nopl   (%rax)
    1266:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    126d:	00 00 00 

0000000000001270 <polling_cq>:
{
    1270:	e8 00 00 00 00       	callq  1275 <polling_cq+0x5>
    1275:	55                   	push   %rbp
	struct ib_wc wc = {0};
    1276:	b9 08 00 00 00       	mov    $0x8,%ecx
{
    127b:	48 89 e5             	mov    %rsp,%rbp
    127e:	41 57                	push   %r15
    1280:	41 56                	push   %r14
    1282:	41 55                	push   %r13
    1284:	41 54                	push   %r12
	struct ib_wc wc = {0};
    1286:	4c 8d 75 90          	lea    -0x70(%rbp),%r14
{
    128a:	53                   	push   %rbx
    128b:	48 89 fb             	mov    %rdi,%rbx
	struct ib_wc wc = {0};
    128e:	4c 89 f7             	mov    %r14,%rdi
{
    1291:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
	DEBUG_LOG(PFX "Polling thread now running\n");
    1298:	44 8b 3d 00 00 00 00 	mov    0x0(%rip),%r15d        # 129f <polling_cq+0x2f>
{
    129f:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    12a6:	00 00 
    12a8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    12ac:	31 c0                	xor    %eax,%eax
	DEBUG_LOG(PFX "Polling thread now running\n");
    12ae:	45 85 ff             	test   %r15d,%r15d
	struct ib_wc wc = {0};
    12b1:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	DEBUG_LOG(PFX "Polling thread now running\n");
    12b4:	0f 85 29 0e 00 00    	jne    20e3 <polling_cq+0xe73>
	return cq->device->ops.poll_cq(cq, num_entries, wc);
    12ba:	48 8b 03             	mov    (%rbx),%rax
    12bd:	4c 89 f2             	mov    %r14,%rdx
    12c0:	be 01 00 00 00       	mov    $0x1,%esi
    12c5:	48 89 df             	mov    %rbx,%rdi
    12c8:	48 8b 40 28          	mov    0x28(%rax),%rax
    12cc:	e8 00 00 00 00       	callq  12d1 <polling_cq+0x61>
	while ((ret = ib_poll_cq(cq, 1, &wc)) >= 0) {
    12d1:	85 c0                	test   %eax,%eax
    12d3:	41 89 c4             	mov    %eax,%r12d
    12d6:	0f 88 db 00 00 00    	js     13b7 <polling_cq+0x147>
		if (kthread_should_stop())
    12dc:	e8 00 00 00 00       	callq  12e1 <polling_cq+0x71>
    12e1:	84 c0                	test   %al,%al
    12e3:	0f 85 ce 00 00 00    	jne    13b7 <polling_cq+0x147>
		if (ret == 0)
    12e9:	45 85 e4             	test   %r12d,%r12d
    12ec:	74 cc                	je     12ba <polling_cq+0x4a>
		if (wc.status) {
    12ee:	8b 55 98             	mov    -0x68(%rbp),%edx
    12f1:	85 d2                	test   %edx,%edx
    12f3:	74 23                	je     1318 <polling_cq+0xa8>
			if (wc.status == IB_WC_WR_FLUSH_ERR) {
    12f5:	83 fa 05             	cmp    $0x5,%edx
    12f8:	0f 85 31 0c 00 00    	jne    1f2f <polling_cq+0xcbf>
				DEBUG_LOG("cq flushed\n");
    12fe:	44 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13d        # 1305 <polling_cq+0x95>
    1305:	45 85 ed             	test   %r13d,%r13d
    1308:	74 b0                	je     12ba <polling_cq+0x4a>
    130a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1311:	e8 00 00 00 00       	callq  1316 <polling_cq+0xa6>
    1316:	eb a2                	jmp    12ba <polling_cq+0x4a>
		switch (wc.opcode) {
    1318:	8b 4d 9c             	mov    -0x64(%rbp),%ecx
    131b:	83 f9 02             	cmp    $0x2,%ecx
    131e:	0f 84 24 04 00 00    	je     1748 <polling_cq+0x4d8>
    1324:	76 5b                	jbe    1381 <polling_cq+0x111>
    1326:	81 f9 80 00 00 00    	cmp    $0x80,%ecx
    132c:	0f 84 9e 03 00 00    	je     16d0 <polling_cq+0x460>
    1332:	81 f9 81 00 00 00    	cmp    $0x81,%ecx
    1338:	0f 84 a0 00 00 00    	je     13de <polling_cq+0x16e>
    133e:	83 f9 07             	cmp    $0x7,%ecx
    1341:	74 1f                	je     1362 <polling_cq+0xf2>
				printk(KERN_ERR PFX
    1343:	ba 45 03 00 00       	mov    $0x345,%edx
    1348:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    134f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1356:	e8 00 00 00 00       	callq  135b <polling_cq+0xeb>
	return -1;
    135b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
				goto error;
    1360:	eb 57                	jmp    13b9 <polling_cq+0x149>
				DEBUG_LOG(PFX "mr registered\n");
    1362:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1368 <polling_cq+0xf8>
    1368:	85 c0                	test   %eax,%eax
    136a:	0f 84 4a ff ff ff    	je     12ba <polling_cq+0x4a>
    1370:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1377:	e8 00 00 00 00       	callq  137c <polling_cq+0x10c>
    137c:	e9 39 ff ff ff       	jmpq   12ba <polling_cq+0x4a>
		switch (wc.opcode) {
    1381:	85 c9                	test   %ecx,%ecx
    1383:	0f 84 e0 03 00 00    	je     1769 <polling_cq+0x4f9>
    1389:	83 f9 01             	cmp    $0x1,%ecx
    138c:	75 b5                	jne    1343 <polling_cq+0xd3>
				if (wc.wc_flags == IB_WC_WITH_IMM) {
    138e:	83 7d bc 02          	cmpl   $0x2,-0x44(%rbp)
    1392:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1398 <polling_cq+0x128>
    1398:	0f 84 3b 04 00 00    	je     17d9 <polling_cq+0x569>
					DEBUG_LOG(PFX "rdma write completion\n");
    139e:	85 c0                	test   %eax,%eax
    13a0:	0f 84 14 ff ff ff    	je     12ba <polling_cq+0x4a>
    13a6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    13ad:	e8 00 00 00 00       	callq  13b2 <polling_cq+0x142>
    13b2:	e9 03 ff ff ff       	jmpq   12ba <polling_cq+0x4a>
			return 0;
    13b7:	31 c0                	xor    %eax,%eax
}
    13b9:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    13bd:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    13c4:	00 00 
    13c6:	0f 85 bd 0c 00 00    	jne    2089 <polling_cq+0xe19>
    13cc:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
    13d3:	5b                   	pop    %rbx
    13d4:	41 5c                	pop    %r12
    13d6:	41 5d                	pop    %r13
    13d8:	41 5e                	pop    %r14
    13da:	41 5f                	pop    %r15
    13dc:	5d                   	pop    %rbp
    13dd:	c3                   	retq   
				DEBUG_LOG(PFX "recv rpc\n");
    13de:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 13e4 <polling_cq+0x174>
    13e4:	85 c0                	test   %eax,%eax
    13e6:	0f 85 fe 0b 00 00    	jne    1fea <polling_cq+0xd7a>
	rw = (struct recv_work *) wc->wr_id;
    13ec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    13f0:	8b 75 b0             	mov    -0x50(%rbp),%esi
	const struct ib_recv_wr *bad_wr = NULL;
    13f3:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    13fa:	00 
	rh = rw->rh;
    13fb:	4c 8b 78 08          	mov    0x8(%rax),%r15
	rw = (struct recv_work *) wc->wr_id;
    13ff:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	imm_data = be32_to_cpu(wc->ex.imm_data);
    1406:	0f ce                	bswap  %esi
	offset = imm_data >> 16;
    1408:	41 89 f0             	mov    %esi,%r8d
	id = imm_data & 0x00007FFF;
    140b:	41 89 f5             	mov    %esi,%r13d
	op = (imm_data & 0x00008000) >> 15;
    140e:	c1 ee 0f             	shr    $0xf,%esi
    1411:	83 e6 01             	and    $0x1,%esi
	offset = imm_data >> 16;
    1414:	41 c1 e8 10          	shr    $0x10,%r8d
	id = imm_data & 0x00007FFF;
    1418:	66 41 81 e5 ff 7f    	and    $0x7fff,%r13w
	op = (imm_data & 0x00008000) >> 15;
    141e:	41 89 f1             	mov    %esi,%r9d
	if (rh->connection_type == CONNECTION_FETCH) {
    1421:	41 8b 47 30          	mov    0x30(%r15),%eax
    1425:	85 c0                	test   %eax,%eax
    1427:	0f 85 2f 04 00 00    	jne    185c <polling_cq+0x5ec>
		if (server) {
    142d:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1433 <polling_cq+0x1c3>
    1433:	85 c0                	test   %eax,%eax
    1435:	0f 84 81 04 00 00    	je     18bc <polling_cq+0x64c>
    143b:	41 0f b7 c5          	movzwl %r13w,%eax
			if (op == 0)
    143f:	45 85 c9             	test   %r9d,%r9d
    1442:	4d 8d a7 20 01 00 00 	lea    0x120(%r15),%r12
    1449:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
    144f:	49 8d 87 00 01 00 00 	lea    0x100(%r15),%rax
	const struct ib_send_wr *bad_wr = NULL;
    1456:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    145d:	00 
    145e:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
			if (op == 0)
    1465:	0f 85 1d 05 00 00    	jne    1988 <polling_cq+0x718>
	rpc_buffer = rh->rpc_buffer + (offset * RPC_ARGS_SIZE);
    146b:	4d 8b 6f 48          	mov    0x48(%r15),%r13
    146f:	41 c1 e0 04          	shl    $0x4,%r8d
    1473:	49 63 c0             	movslq %r8d,%rax
    1476:	49 01 c5             	add    %rax,%r13
	ib_dma_sync_single_for_cpu(rh->device, rh->rpc_dma_addr + (offset * RPC_ARGS_SIZE), RPC_ARGS_SIZE, DMA_BIDIRECTIONAL);
    1479:	49 03 47 70          	add    0x70(%r15),%rax
    147d:	48 89 c6             	mov    %rax,%rsi
    1480:	49 8b 87 30 01 00 00 	mov    0x130(%r15),%rax
    1487:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    148a:	48 85 ff             	test   %rdi,%rdi
    148d:	0f 84 19 0a 00 00    	je     1eac <polling_cq+0xc3c>
    1493:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    149a:	48 85 c0             	test   %rax,%rax
    149d:	0f 84 09 0a 00 00    	je     1eac <polling_cq+0xc3c>
	else if (ops->sync_single_for_cpu)
    14a3:	48 8b 40 50          	mov    0x50(%rax),%rax
    14a7:	48 85 c0             	test   %rax,%rax
    14aa:	74 0c                	je     14b8 <polling_cq+0x248>
		ops->sync_single_for_cpu(dev, addr, size, dir);
    14ac:	31 c9                	xor    %ecx,%ecx
    14ae:	ba 10 00 00 00       	mov    $0x10,%edx
    14b3:	e8 00 00 00 00       	callq  14b8 <polling_cq+0x248>
	dest = (void *) *((uint64_t *) (rpc_buffer));
    14b8:	49 8b 45 00          	mov    0x0(%r13),%rax
    14bc:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
	order = *((uint64_t *) (rpc_buffer + 8));
    14c3:	49 8b 45 08          	mov    0x8(%r13),%rax
	num_page = 1 << order;
    14c7:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    14cd:	89 c1                	mov    %eax,%ecx
	order = *((uint64_t *) (rpc_buffer + 8));
    14cf:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
	DEBUG_LOG(PFX "dest: %llx order: %u num_page: %d\n", (uint64_t) dest, order, num_page);
    14d6:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 14dc <polling_cq+0x26c>
	num_page = 1 << order;
    14dc:	41 d3 e5             	shl    %cl,%r13d
	DEBUG_LOG(PFX "dest: %llx order: %u num_page: %d\n", (uint64_t) dest, order, num_page);
    14df:	85 c0                	test   %eax,%eax
    14e1:	0f 85 3c 0c 00 00    	jne    2123 <polling_cq+0xeb3>
    14e7:	48 89 9d 50 ff ff ff 	mov    %rbx,-0xb0(%rbp)
    14ee:	48 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%rbx
    14f5:	eb 0c                	jmp    1503 <polling_cq+0x293>
    14f7:	4c 89 e7             	mov    %r12,%rdi
    14fa:	ff 14 25 00 00 00 00 	callq  *0x0

static inline void __raw_spin_unlock(raw_spinlock_t *lock)
{
	spin_release(&lock->dep_map, 1, _RET_IP_);
	do_raw_spin_unlock(lock);
	preempt_enable();
    1501:	0f 0b                	ud2    
    1503:	4c 89 e7             	mov    %r12,%rdi
    1506:	e8 00 00 00 00       	callq  150b <polling_cq+0x29b>
			   unsigned long size,
			   unsigned long start,
			   unsigned int nr,
			   unsigned long align_mask)
{
	return bitmap_find_next_zero_area_off(map, size, start, nr,
    150b:	45 31 c9             	xor    %r9d,%r9d
    150e:	45 31 c0             	xor    %r8d,%r8d
    1511:	31 d2                	xor    %edx,%edx
    1513:	44 89 e9             	mov    %r13d,%ecx
    1516:	be 00 01 00 00       	mov    $0x100,%esi
    151b:	48 89 df             	mov    %rbx,%rdi
    151e:	e8 00 00 00 00       	callq  1523 <polling_cq+0x2b3>
		if (i < NR_SINK_SLOTS) break;
    1523:	3d ff 00 00 00       	cmp    $0xff,%eax
    1528:	41 89 c3             	mov    %eax,%r11d
    152b:	77 ca                	ja     14f7 <polling_cq+0x287>
		 IS_ALIGNED(start, BITMAP_MEM_ALIGNMENT) &&
		 __builtin_constant_p(nbits & BITMAP_MEM_MASK) &&
		 IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))
		memset((char *)map + start / 8, 0xff, nbits / 8);
	else
		__bitmap_set(map, start, nbits);
    152d:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    1534:	44 89 ea             	mov    %r13d,%edx
    1537:	44 89 de             	mov    %r11d,%esi
    153a:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%rbp)
    1540:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
    1547:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    154e:	e8 00 00 00 00       	callq  1553 <polling_cq+0x2e3>
    1553:	4c 89 e7             	mov    %r12,%rdi
    1556:	ff 14 25 00 00 00 00 	callq  *0x0
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    155d:	48 63 85 40 ff ff ff 	movslq -0xc0(%rbp),%rax
    1564:	4d 8b 67 50          	mov    0x50(%r15),%r12
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE * num_page, remote_sink_dma_addr, rh->sink_rkey);
    1568:	4d 63 ed             	movslq %r13d,%r13
	sink_dma_addr = rh->sink_dma_addr + (i * PAGE_SIZE);
    156b:	4d 8b 57 78          	mov    0x78(%r15),%r10
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE * num_page, remote_sink_dma_addr, rh->sink_rkey);
    156f:	45 8b 87 d4 00 00 00 	mov    0xd4(%r15),%r8d
    1576:	49 c1 e5 0c          	shl    $0xc,%r13
    157a:	4c 89 ea             	mov    %r13,%rdx
    157d:	4c 89 ff             	mov    %r15,%rdi
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    1580:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
    1586:	48 c1 e0 0c          	shl    $0xc,%rax
	sink_dma_addr = rh->sink_dma_addr + (i * PAGE_SIZE);
    158a:	49 01 c2             	add    %rax,%r10
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    158d:	49 01 c4             	add    %rax,%r12
	remote_sink_dma_addr = rh->remote_sink_dma_addr + (i * PAGE_SIZE);
    1590:	49 03 87 b8 00 00 00 	add    0xb8(%r15),%rax
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE * num_page, remote_sink_dma_addr, rh->sink_rkey);
    1597:	4c 89 d6             	mov    %r10,%rsi
    159a:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
	remote_sink_dma_addr = rh->remote_sink_dma_addr + (i * PAGE_SIZE);
    15a1:	48 89 c1             	mov    %rax,%rcx
    15a4:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE * num_page, remote_sink_dma_addr, rh->sink_rkey);
    15ab:	e8 50 ea ff ff       	callq  0 <__get_rdma_work>
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id);
    15b0:	44 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%r11d
	rw->dma_addr = sink_dma_addr;
    15b7:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE * num_page, remote_sink_dma_addr, rh->sink_rkey);
    15be:	49 89 c0             	mov    %rax,%r8
	rw->work_type = WORK_TYPE_RPC;
    15c1:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%rax)
	rw->addr = sink_addr;
    15c8:	4c 89 60 68          	mov    %r12,0x68(%rax)
	rw->done = false;
    15cc:	c6 40 60 00          	movb   $0x0,0x60(%rax)
	rw->rh = rh;
    15d0:	4c 89 78 08          	mov    %r15,0x8(%rax)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id);
    15d4:	44 89 d9             	mov    %r11d,%ecx
	rw->dma_addr = sink_dma_addr;
    15d7:	4c 89 50 70          	mov    %r10,0x70(%rax)
	rw->slot = i;
    15db:	4c 8b 8d 48 ff ff ff 	mov    -0xb8(%rbp),%r9
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id);
    15e2:	c1 e1 10             	shl    $0x10,%ecx
    15e5:	0b 8d 6c ff ff ff    	or     -0x94(%rbp),%ecx
    15eb:	0f c9                	bswap  %ecx
    15ed:	89 48 4c             	mov    %ecx,0x4c(%rax)
	rw->order = order;
    15f0:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
	rw->slot = i;
    15f6:	45 89 48 78          	mov    %r9d,0x78(%r8)
	rw->order = order;
    15fa:	41 89 40 7c          	mov    %eax,0x7c(%r8)
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, id, rw->wr.wr.ex.imm_data);
    15fe:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1604 <polling_cq+0x394>
    1604:	85 c0                	test   %eax,%eax
    1606:	0f 85 e8 0a 00 00    	jne    20f4 <polling_cq+0xe84>
		if (q_size < size)
			__read_overflow2();
	}
	if (p_size < size || q_size < size)
		fortify_panic(__func__);
	return __builtin_memcpy(p, q, size);
    160c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
    1613:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
    1618:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    161c:	48 8b 01             	mov    (%rcx),%rax
    161f:	49 89 04 24          	mov    %rax,(%r12)
    1623:	48 8b 81 f8 0f 00 00 	mov    0xff8(%rcx),%rax
    162a:	49 89 84 24 f8 0f 00 	mov    %rax,0xff8(%r12)
    1631:	00 
    1632:	49 29 fc             	sub    %rdi,%r12
    1635:	4c 29 e1             	sub    %r12,%rcx
    1638:	41 81 c4 00 10 00 00 	add    $0x1000,%r12d
    163f:	41 c1 ec 03          	shr    $0x3,%r12d
    1643:	48 89 ce             	mov    %rcx,%rsi
    1646:	44 89 e1             	mov    %r12d,%ecx
    1649:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	ib_dma_sync_single_for_cpu(rh->device, sink_dma_addr, num_page * PAGE_SIZE, DMA_BIDIRECTIONAL);
    164c:	49 8b 87 30 01 00 00 	mov    0x130(%r15),%rax
    1653:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    1656:	48 85 ff             	test   %rdi,%rdi
    1659:	0f 84 a0 08 00 00    	je     1eff <polling_cq+0xc8f>
    165f:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    1666:	48 85 c0             	test   %rax,%rax
    1669:	0f 84 90 08 00 00    	je     1eff <polling_cq+0xc8f>
	else if (ops->sync_single_for_cpu)
    166f:	48 8b 40 50          	mov    0x50(%rax),%rax
    1673:	48 85 c0             	test   %rax,%rax
    1676:	74 1b                	je     1693 <polling_cq+0x423>
    1678:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
		ops->sync_single_for_cpu(dev, addr, size, dir);
    167f:	31 c9                	xor    %ecx,%ecx
    1681:	4c 89 ea             	mov    %r13,%rdx
    1684:	4c 89 d6             	mov    %r10,%rsi
    1687:	e8 00 00 00 00       	callq  168c <polling_cq+0x41c>
    168c:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
	DEBUG_LOG(PFX "rkey %x, remote_dma_addr %llx\n", rh->sink_rkey, remote_sink_dma_addr);
    1693:	44 8b 25 00 00 00 00 	mov    0x0(%rip),%r12d        # 169a <polling_cq+0x42a>
    169a:	45 85 e4             	test   %r12d,%r12d
    169d:	0f 84 50 04 00 00    	je     1af3 <polling_cq+0x883>
    16a3:	41 8b b7 d4 00 00 00 	mov    0xd4(%r15),%esi
    16aa:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
    16b1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    16b8:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    16bf:	e8 00 00 00 00       	callq  16c4 <polling_cq+0x454>
    16c4:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
    16cb:	e9 23 04 00 00       	jmpq   1af3 <polling_cq+0x883>
				DEBUG_LOG(PFX "recv completion\n");
    16d0:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 16d6 <polling_cq+0x466>
    16d6:	85 ff                	test   %edi,%edi
    16d8:	0f 85 d6 09 00 00    	jne    20b4 <polling_cq+0xe44>
	rw = (struct recv_work *) wc->wr_id;
    16de:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
	switch (rw->work_type) {
    16e2:	41 8b 45 00          	mov    0x0(%r13),%eax
	rh = rw->rh;
    16e6:	4d 8b 65 08          	mov    0x8(%r13),%r12
	switch (rw->work_type) {
    16ea:	83 f8 01             	cmp    $0x1,%eax
    16ed:	0f 84 1d 01 00 00    	je     1810 <polling_cq+0x5a0>
    16f3:	83 f8 02             	cmp    $0x2,%eax
    16f6:	0f 85 be fb ff ff    	jne    12ba <polling_cq+0x4a>
			ib_dma_unmap_single(rh->device, rw->dma_addr, 
    16fc:	49 8b 84 24 30 01 00 	mov    0x130(%r12),%rax
    1703:	00 
    1704:	49 8b 75 40          	mov    0x40(%r13),%rsi
    1708:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    170b:	48 85 ff             	test   %rdi,%rdi
    170e:	0f 84 03 05 00 00    	je     1c17 <polling_cq+0x9a7>
    1714:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    171b:	48 85 c0             	test   %rax,%rax
    171e:	0f 84 f3 04 00 00    	je     1c17 <polling_cq+0x9a7>
	else if (ops->unmap_page)
    1724:	48 8b 40 28          	mov    0x28(%rax),%rax
    1728:	48 85 c0             	test   %rax,%rax
    172b:	0f 84 08 05 00 00    	je     1c39 <polling_cq+0x9c9>
		ops->unmap_page(dev, addr, size, dir, attrs);
    1731:	45 31 c0             	xor    %r8d,%r8d
    1734:	b9 02 00 00 00       	mov    $0x2,%ecx
    1739:	ba 18 00 00 00       	mov    $0x18,%edx
    173e:	e8 00 00 00 00       	callq  1743 <polling_cq+0x4d3>
    1743:	e9 f1 04 00 00       	jmpq   1c39 <polling_cq+0x9c9>
				DEBUG_LOG(PFX "rdma read completion\n");
    1748:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 174f <polling_cq+0x4df>
    174f:	45 85 c0             	test   %r8d,%r8d
    1752:	0f 84 62 fb ff ff    	je     12ba <polling_cq+0x4a>
    1758:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    175f:	e8 00 00 00 00       	callq  1764 <polling_cq+0x4f4>
    1764:	e9 51 fb ff ff       	jmpq   12ba <polling_cq+0x4a>
				DEBUG_LOG(PFX "send completion\n");
    1769:	44 8b 25 00 00 00 00 	mov    0x0(%rip),%r12d        # 1770 <polling_cq+0x500>
    1770:	45 85 e4             	test   %r12d,%r12d
    1773:	0f 85 2b 08 00 00    	jne    1fa4 <polling_cq+0xd34>
	sw = (struct send_work *) wc->wr_id;
    1779:	4c 8b 65 90          	mov    -0x70(%rbp),%r12
	switch (sw->work_type) {
    177d:	41 83 3c 24 04       	cmpl   $0x4,(%r12)
    1782:	0f 85 32 fb ff ff    	jne    12ba <polling_cq+0x4a>
	dma_addr = sw->sgl.addr;
    1788:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
	rh = sw->rh;
    178d:	49 8b 44 24 08       	mov    0x8(%r12),%rax
			ib_dma_unmap_single(rh->device, dma_addr, 
    1792:	48 8b 80 30 01 00 00 	mov    0x130(%rax),%rax
    1799:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    179c:	48 85 ff             	test   %rdi,%rdi
    179f:	0f 84 4b 06 00 00    	je     1df0 <polling_cq+0xb80>
    17a5:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    17ac:	48 85 c0             	test   %rax,%rax
    17af:	0f 84 3b 06 00 00    	je     1df0 <polling_cq+0xb80>
	else if (ops->unmap_page)
    17b5:	48 8b 40 28          	mov    0x28(%rax),%rax
    17b9:	48 85 c0             	test   %rax,%rax
    17bc:	0f 84 50 06 00 00    	je     1e12 <polling_cq+0xba2>
		ops->unmap_page(dev, addr, size, dir, attrs);
    17c2:	45 31 c0             	xor    %r8d,%r8d
    17c5:	b9 01 00 00 00       	mov    $0x1,%ecx
    17ca:	ba 18 00 00 00       	mov    $0x18,%edx
    17cf:	e8 00 00 00 00       	callq  17d4 <polling_cq+0x564>
    17d4:	e9 39 06 00 00       	jmpq   1e12 <polling_cq+0xba2>
					DEBUG_LOG(PFX "rdma write-imm completion\n");
    17d9:	85 c0                	test   %eax,%eax
    17db:	0f 85 b2 07 00 00    	jne    1f93 <polling_cq+0xd23>
					if (server)
    17e1:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 17e8 <polling_cq+0x578>
    17e8:	4c 8b 65 90          	mov    -0x70(%rbp),%r12
    17ec:	45 85 c9             	test   %r9d,%r9d
    17ef:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
    17f4:	0f 85 b8 03 00 00    	jne    1bb2 <polling_cq+0x942>
						if (rw->rh->connection_type == CONNECTION_EVICT)
    17fa:	41 83 7d 30 01       	cmpl   $0x1,0x30(%r13)
    17ff:	0f 85 b5 fa ff ff    	jne    12ba <polling_cq+0x4a>
							rw->done = true;
    1805:	41 c6 44 24 60 01    	movb   $0x1,0x60(%r12)
    180b:	e9 aa fa ff ff       	jmpq   12ba <polling_cq+0x4a>
			ib_dma_unmap_single(rh->device, rw->dma_addr, 
    1810:	49 8b 84 24 30 01 00 	mov    0x130(%r12),%rax
    1817:	00 
    1818:	49 8b 75 40          	mov    0x40(%r13),%rsi
    181c:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    181f:	48 85 ff             	test   %rdi,%rdi
    1822:	0f 84 83 04 00 00    	je     1cab <polling_cq+0xa3b>
    1828:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    182f:	48 85 c0             	test   %rax,%rax
    1832:	0f 84 73 04 00 00    	je     1cab <polling_cq+0xa3b>
	else if (ops->unmap_page)
    1838:	48 8b 40 28          	mov    0x28(%rax),%rax
    183c:	48 85 c0             	test   %rax,%rax
    183f:	0f 84 88 04 00 00    	je     1ccd <polling_cq+0xa5d>
		ops->unmap_page(dev, addr, size, dir, attrs);
    1845:	45 31 c0             	xor    %r8d,%r8d
    1848:	b9 02 00 00 00       	mov    $0x2,%ecx
    184d:	ba 18 00 00 00       	mov    $0x18,%edx
    1852:	e8 00 00 00 00       	callq  1857 <polling_cq+0x5e7>
    1857:	e9 71 04 00 00       	jmpq   1ccd <polling_cq+0xa5d>
	rpc_buffer = rh->rpc_buffer + (offset * RPC_ARGS_SIZE + PAGE_SIZE);
    185c:	49 8b 47 48          	mov    0x48(%r15),%rax
    1860:	41 c1 e0 04          	shl    $0x4,%r8d
    1864:	4d 63 c0             	movslq %r8d,%r8
    1867:	4e 8d a4 00 00 10 00 	lea    0x1000(%rax,%r8,1),%r12
    186e:	00 
	ib_dma_sync_single_for_cpu(rh->device, rh->rpc_dma_addr + (offset * RPC_ARGS_SIZE + PAGE_SIZE), RPC_ARGS_SIZE + PAGE_SIZE, DMA_BIDIRECTIONAL);
    186f:	49 8b 47 70          	mov    0x70(%r15),%rax
    1873:	49 8d b4 00 00 10 00 	lea    0x1000(%r8,%rax,1),%rsi
    187a:	00 
    187b:	49 8b 87 30 01 00 00 	mov    0x130(%r15),%rax
    1882:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    1885:	48 85 ff             	test   %rdi,%rdi
    1888:	0f 84 b1 04 00 00    	je     1d3f <polling_cq+0xacf>
    188e:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    1895:	48 85 c0             	test   %rax,%rax
    1898:	0f 84 a1 04 00 00    	je     1d3f <polling_cq+0xacf>
	else if (ops->sync_single_for_cpu)
    189e:	48 8b 40 50          	mov    0x50(%rax),%rax
    18a2:	48 85 c0             	test   %rax,%rax
    18a5:	0f 84 b0 04 00 00    	je     1d5b <polling_cq+0xaeb>
		ops->sync_single_for_cpu(dev, addr, size, dir);
    18ab:	31 c9                	xor    %ecx,%ecx
    18ad:	ba 10 10 00 00       	mov    $0x1010,%edx
    18b2:	e8 00 00 00 00       	callq  18b7 <polling_cq+0x647>
    18b7:	e9 9f 04 00 00       	jmpq   1d5b <polling_cq+0xaeb>
    18bc:	45 0f b7 ed          	movzwl %r13w,%r13d
    18c0:	4d 8b 67 50          	mov    0x50(%r15),%r12
    18c4:	49 8b 77 78          	mov    0x78(%r15),%rsi
    18c8:	4c 89 e8             	mov    %r13,%rax
    18cb:	49 c1 e0 0c          	shl    $0xc,%r8
    18cf:	48 c1 e0 04          	shl    $0x4,%rax
    18d3:	49 01 c5             	add    %rax,%r13
    18d6:	49 8b 87 90 00 00 00 	mov    0x90(%r15),%rax
    18dd:	4d 01 c4             	add    %r8,%r12
    18e0:	4c 01 c6             	add    %r8,%rsi
			if (op == 0)
    18e3:	45 85 c9             	test   %r9d,%r9d
    18e6:	4e 8d 2c e8          	lea    (%rax,%r13,8),%r13
    18ea:	49 8b 87 30 01 00 00 	mov    0x130(%r15),%rax
    18f1:	48 8b 38             	mov    (%rax),%rdi
    18f4:	0f 85 3a 02 00 00    	jne    1b34 <polling_cq+0x8c4>
	num_page = 1 << rw->order;
    18fa:	41 8b 4d 7c          	mov    0x7c(%r13),%ecx
    18fe:	b8 01 00 00 00       	mov    $0x1,%eax
    1903:	d3 e0                	shl    %cl,%eax
	ib_dma_sync_single_for_cpu(rh->device, sink_dma_addr, PAGE_SIZE * num_page, DMA_BIDIRECTIONAL);
    1905:	48 98                	cltq   
    1907:	48 c1 e0 0c          	shl    $0xc,%rax
	if (dev && dev->dma_ops)
    190b:	48 85 ff             	test   %rdi,%rdi
    190e:	49 89 c0             	mov    %rax,%r8
    1911:	0f 84 68 05 00 00    	je     1e7f <polling_cq+0xc0f>
    1917:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    191e:	48 85 c0             	test   %rax,%rax
    1921:	0f 84 58 05 00 00    	je     1e7f <polling_cq+0xc0f>
	else if (ops->sync_single_for_cpu)
    1927:	48 8b 40 50          	mov    0x50(%rax),%rax
    192b:	48 85 c0             	test   %rax,%rax
    192e:	74 18                	je     1948 <polling_cq+0x6d8>
		ops->sync_single_for_cpu(dev, addr, size, dir);
    1930:	4c 89 c2             	mov    %r8,%rdx
    1933:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    193a:	31 c9                	xor    %ecx,%ecx
    193c:	e8 00 00 00 00       	callq  1941 <polling_cq+0x6d1>
    1941:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
    1948:	49 8b bd 80 00 00 00 	mov    0x80(%r13),%rdi
    194f:	4c 89 c2             	mov    %r8,%rdx
    1952:	4c 89 e6             	mov    %r12,%rsi
    1955:	e8 00 00 00 00       	callq  195a <polling_cq+0x6ea>
	DEBUG_LOG(PFX "done %p %d\n", rw, rw->done);
    195a:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 1961 <polling_cq+0x6f1>
	rw->done = true;
    1961:	41 c6 45 60 01       	movb   $0x1,0x60(%r13)
	DEBUG_LOG(PFX "done %p %d\n", rw, rw->done);
    1966:	45 85 c0             	test   %r8d,%r8d
    1969:	0f 84 38 04 00 00    	je     1da7 <polling_cq+0xb37>
    196f:	ba 01 00 00 00       	mov    $0x1,%edx
    1974:	4c 89 ee             	mov    %r13,%rsi
    1977:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    197e:	e8 00 00 00 00       	callq  1983 <polling_cq+0x713>
    1983:	e9 1f 04 00 00       	jmpq   1da7 <polling_cq+0xb37>
	const struct ib_send_wr *bad_wr = NULL;
    1988:	48 89 9d 60 ff ff ff 	mov    %rbx,-0xa0(%rbp)
    198f:	48 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%rbx
    1996:	eb 0c                	jmp    19a4 <polling_cq+0x734>
    1998:	4c 89 e7             	mov    %r12,%rdi
    199b:	ff 14 25 00 00 00 00 	callq  *0x0
    19a2:	0f 0b                	ud2    
    19a4:	4c 89 e7             	mov    %r12,%rdi
    19a7:	e8 00 00 00 00       	callq  19ac <polling_cq+0x73c>
	return bitmap_find_next_zero_area_off(map, size, start, nr,
    19ac:	45 31 c9             	xor    %r9d,%r9d
    19af:	45 31 c0             	xor    %r8d,%r8d
    19b2:	31 d2                	xor    %edx,%edx
    19b4:	b9 01 00 00 00       	mov    $0x1,%ecx
    19b9:	be 00 01 00 00       	mov    $0x100,%esi
    19be:	48 89 df             	mov    %rbx,%rdi
    19c1:	e8 00 00 00 00       	callq  19c6 <polling_cq+0x756>
		if (i < NR_SINK_SLOTS) break;
    19c6:	3d ff 00 00 00       	cmp    $0xff,%eax
    19cb:	77 cb                	ja     1998 <polling_cq+0x728>
    19cd:	49 89 c1             	mov    %rax,%r9
    19d0:	48 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%rbx
		__set_bit(start, map);
    19d7:	89 c0                	mov    %eax,%eax
 * If it's called on the same region of memory simultaneously, the effect
 * may be that only one operation succeeds.
 */
static __always_inline void __set_bit(long nr, volatile unsigned long *addr)
{
	asm volatile(__ASM_SIZE(bts) " %1,%0" : : ADDR, "Ir" (nr) : "memory");
    19d9:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
    19e0:	48 0f ab 01          	bts    %rax,(%rcx)
    19e4:	4c 89 e7             	mov    %r12,%rdi
    19e7:	ff 14 25 00 00 00 00 	callq  *0x0
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    19ee:	4d 8b 57 50          	mov    0x50(%r15),%r10
	sink_dma_addr = rh->sink_dma_addr + (i * PAGE_SIZE);
    19f2:	4d 8b 67 78          	mov    0x78(%r15),%r12
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    19f6:	49 63 c1             	movslq %r9d,%rax
    19f9:	48 c1 e0 0c          	shl    $0xc,%rax
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE, remote_sink_dma_addr, rh->sink_rkey);
    19fd:	45 8b 87 d4 00 00 00 	mov    0xd4(%r15),%r8d
    1a04:	ba 00 10 00 00       	mov    $0x1000,%edx
    1a09:	4c 89 ff             	mov    %r15,%rdi
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    1a0c:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id | 0x8000);
    1a13:	66 41 81 cd 00 80    	or     $0x8000,%r13w
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    1a19:	49 01 c2             	add    %rax,%r10
	sink_dma_addr = rh->sink_dma_addr + (i * PAGE_SIZE);
    1a1c:	49 01 c4             	add    %rax,%r12
	remote_sink_dma_addr = rh->remote_sink_dma_addr + (i * PAGE_SIZE);
    1a1f:	49 03 87 b8 00 00 00 	add    0xb8(%r15),%rax
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE, remote_sink_dma_addr, rh->sink_rkey);
    1a26:	4c 89 e6             	mov    %r12,%rsi
	sink_addr = ((uint8_t *) rh->sink_buffer) + (i * PAGE_SIZE);
    1a29:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
	remote_sink_dma_addr = rh->remote_sink_dma_addr + (i * PAGE_SIZE);
    1a30:	48 89 c1             	mov    %rax,%rcx
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE, remote_sink_dma_addr, rh->sink_rkey);
    1a33:	e8 c8 e5 ff ff       	callq  0 <__get_rdma_work>
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id | 0x8000);
    1a38:	4c 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%r9
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, id, rw->wr.wr.ex.imm_data);
    1a3f:	44 8b 1d 00 00 00 00 	mov    0x0(%rip),%r11d        # 1a46 <polling_cq+0x7d6>
	rw = __get_rdma_work(rh, sink_dma_addr, PAGE_SIZE, remote_sink_dma_addr, rh->sink_rkey);
    1a46:	49 89 c0             	mov    %rax,%r8
	rw->addr = sink_addr;
    1a49:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id | 0x8000);
    1a50:	41 0f b7 c5          	movzwl %r13w,%eax
	rw->work_type = WORK_TYPE_RPC;
    1a54:	41 c7 40 04 05 00 00 	movl   $0x5,0x4(%r8)
    1a5b:	00 
	rw->dma_addr = sink_dma_addr;
    1a5c:	4d 89 60 70          	mov    %r12,0x70(%r8)
	rw->done = false;
    1a60:	41 c6 40 60 00       	movb   $0x0,0x60(%r8)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id | 0x8000);
    1a65:	44 89 c9             	mov    %r9d,%ecx
	rw->rh = rh;
    1a68:	4d 89 78 08          	mov    %r15,0x8(%r8)
	rw->order = 0;
    1a6c:	41 c7 40 7c 00 00 00 	movl   $0x0,0x7c(%r8)
    1a73:	00 
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id | 0x8000);
    1a74:	c1 e1 10             	shl    $0x10,%ecx
	rw->addr = sink_addr;
    1a77:	4d 89 50 68          	mov    %r10,0x68(%r8)
	rw->slot = i;
    1a7b:	45 89 48 78          	mov    %r9d,0x78(%r8)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id | 0x8000);
    1a7f:	09 c1                	or     %eax,%ecx
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, id, rw->wr.wr.ex.imm_data);
    1a81:	45 85 db             	test   %r11d,%r11d
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | id | 0x8000);
    1a84:	0f c9                	bswap  %ecx
    1a86:	41 89 48 4c          	mov    %ecx,0x4c(%r8)
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, id, rw->wr.wr.ex.imm_data);
    1a8a:	0f 85 c0 04 00 00    	jne    1f50 <polling_cq+0xce0>
	*((uint64_t *) sink_addr) = (uint64_t) my_data;
    1a90:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1a97 <polling_cq+0x827>
    1a97:	49 89 02             	mov    %rax,(%r10)
	ib_dma_sync_single_for_cpu(rh->device, sink_dma_addr, PAGE_SIZE, DMA_BIDIRECTIONAL);
    1a9a:	49 8b 87 30 01 00 00 	mov    0x130(%r15),%rax
    1aa1:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    1aa4:	48 85 ff             	test   %rdi,%rdi
    1aa7:	0f 84 20 04 00 00    	je     1ecd <polling_cq+0xc5d>
    1aad:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    1ab4:	48 85 c0             	test   %rax,%rax
    1ab7:	0f 84 10 04 00 00    	je     1ecd <polling_cq+0xc5d>
	else if (ops->sync_single_for_cpu)
    1abd:	48 8b 40 50          	mov    0x50(%rax),%rax
    1ac1:	48 85 c0             	test   %rax,%rax
    1ac4:	74 1d                	je     1ae3 <polling_cq+0x873>
    1ac6:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
		ops->sync_single_for_cpu(dev, addr, size, dir);
    1acd:	31 c9                	xor    %ecx,%ecx
    1acf:	ba 00 10 00 00       	mov    $0x1000,%edx
    1ad4:	4c 89 e6             	mov    %r12,%rsi
    1ad7:	e8 00 00 00 00       	callq  1adc <polling_cq+0x86c>
    1adc:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
	DEBUG_LOG(PFX "allocating addr %llx\n", (uint64_t) my_data);
    1ae3:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 1aea <polling_cq+0x87a>
    1aea:	45 85 c9             	test   %r9d,%r9d
    1aed:	0f 85 9b 05 00 00    	jne    208e <polling_cq+0xe1e>
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    1af3:	49 8b bf 40 01 00 00 	mov    0x140(%r15),%rdi
    1afa:	49 8d 70 28          	lea    0x28(%r8),%rsi
	return qp->device->ops.post_send(qp, send_wr, bad_send_wr ? : &dummy);
    1afe:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
    1b02:	48 8b 07             	mov    (%rdi),%rax
    1b05:	48 8b 40 08          	mov    0x8(%rax),%rax
    1b09:	e8 00 00 00 00       	callq  1b0e <polling_cq+0x89e>
	if (ret || bad_wr) {
    1b0e:	85 c0                	test   %eax,%eax
    1b10:	75 0b                	jne    1b1d <polling_cq+0x8ad>
    1b12:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
    1b17:	0f 84 8a 02 00 00    	je     1da7 <polling_cq+0xb37>
		printk(KERN_ERR PFX "Cannot post send wr, %d %p\n", ret, bad_wr);
    1b1d:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
    1b21:	89 c6                	mov    %eax,%esi
    1b23:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1b2a:	e8 00 00 00 00       	callq  1b2f <polling_cq+0x8bf>
    1b2f:	e9 73 02 00 00       	jmpq   1da7 <polling_cq+0xb37>
	if (dev && dev->dma_ops)
    1b34:	48 85 ff             	test   %rdi,%rdi
    1b37:	0f 84 21 03 00 00    	je     1e5e <polling_cq+0xbee>
    1b3d:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    1b44:	48 85 c0             	test   %rax,%rax
    1b47:	0f 84 11 03 00 00    	je     1e5e <polling_cq+0xbee>
	else if (ops->sync_single_for_cpu)
    1b4d:	48 8b 40 50          	mov    0x50(%rax),%rax
    1b51:	48 85 c0             	test   %rax,%rax
    1b54:	74 0c                	je     1b62 <polling_cq+0x8f2>
		ops->sync_single_for_cpu(dev, addr, size, dir);
    1b56:	31 c9                	xor    %ecx,%ecx
    1b58:	ba 00 10 00 00       	mov    $0x1000,%edx
    1b5d:	e8 00 00 00 00       	callq  1b62 <polling_cq+0x8f2>
	DEBUG_LOG(PFX "allocated addr %llx\n", (uint64_t) remote_data);
    1b62:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 1b68 <polling_cq+0x8f8>
	remote_data = (char *) *((uint64_t *) sink_addr);
    1b68:	49 8b 34 24          	mov    (%r12),%rsi
	rw->done = true;
    1b6c:	41 c6 45 60 01       	movb   $0x1,0x60(%r13)
	DEBUG_LOG(PFX "allocated addr %llx\n", (uint64_t) remote_data);
    1b71:	85 ff                	test   %edi,%edi
	remote_data = (char *) *((uint64_t *) sink_addr);
    1b73:	48 89 35 00 00 00 00 	mov    %rsi,0x0(%rip)        # 1b7a <polling_cq+0x90a>
	DEBUG_LOG(PFX "allocated addr %llx\n", (uint64_t) remote_data);
    1b7a:	0f 84 27 02 00 00    	je     1da7 <polling_cq+0xb37>
    1b80:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1b87:	e8 00 00 00 00       	callq  1b8c <polling_cq+0x91c>
	DEBUG_LOG(PFX "done %p %d\n", rw, rw->done);
    1b8c:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1b93 <polling_cq+0x923>
    1b93:	0f 84 0e 02 00 00    	je     1da7 <polling_cq+0xb37>
    1b99:	41 0f b6 55 60       	movzbl 0x60(%r13),%edx
    1b9e:	4c 89 ee             	mov    %r13,%rsi
    1ba1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1ba8:	e8 00 00 00 00       	callq  1bad <polling_cq+0x93d>
    1bad:	e9 f5 01 00 00       	jmpq   1da7 <polling_cq+0xb37>
    1bb2:	49 8d 85 20 01 00 00 	lea    0x120(%r13),%rax
	slot = rw->slot;
    1bb9:	41 8b 74 24 78       	mov    0x78(%r12),%esi
	unsigned int num_pages = 1 << order;
    1bbe:	41 8b 4c 24 7c       	mov    0x7c(%r12),%ecx
    1bc3:	41 bf 01 00 00 00    	mov    $0x1,%r15d
    1bc9:	48 89 c7             	mov    %rax,%rdi
    1bcc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    1bd3:	41 d3 e7             	shl    %cl,%r15d
	slot = rw->slot;
    1bd6:	89 b5 70 ff ff ff    	mov    %esi,-0x90(%rbp)
    1bdc:	e8 00 00 00 00       	callq  1be1 <polling_cq+0x971>
		 IS_ALIGNED(start, BITMAP_MEM_ALIGNMENT) &&
		 __builtin_constant_p(nbits & BITMAP_MEM_MASK) &&
		 IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))
		memset((char *)map + start / 8, 0, nbits / 8);
	else
		__bitmap_clear(map, start, nbits);
    1be1:	8b b5 70 ff ff ff    	mov    -0x90(%rbp),%esi
	bitmap_clear(rh->sink_slots, slot, num_pages);
    1be7:	49 8d bd 00 01 00 00 	lea    0x100(%r13),%rdi
    1bee:	44 89 fa             	mov    %r15d,%edx
    1bf1:	e8 00 00 00 00       	callq  1bf6 <polling_cq+0x986>
    1bf6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    1bfd:	48 89 c7             	mov    %rax,%rdi
    1c00:	ff 14 25 00 00 00 00 	callq  *0x0
	__put_rdma_work(rh, rw);
    1c07:	4c 89 e6             	mov    %r12,%rsi
    1c0a:	4c 89 ef             	mov    %r13,%rdi
    1c0d:	e8 2e e5 ff ff       	callq  140 <__put_rdma_work>
    1c12:	e9 a3 f6 ff ff       	jmpq   12ba <polling_cq+0x4a>
    1c17:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1c1e <polling_cq+0x9ae>
	if (dma_is_direct(ops))
    1c1e:	48 85 c0             	test   %rax,%rax
    1c21:	0f 85 fd fa ff ff    	jne    1724 <polling_cq+0x4b4>
		dma_direct_unmap_page(dev, addr, size, dir, attrs);
    1c27:	45 31 c0             	xor    %r8d,%r8d
    1c2a:	b9 02 00 00 00       	mov    $0x2,%ecx
    1c2f:	ba 18 00 00 00       	mov    $0x18,%edx
    1c34:	e8 00 00 00 00       	callq  1c39 <polling_cq+0x9c9>
			if (rh->connection_type == CONNECTION_FETCH)
    1c39:	41 8b 54 24 30       	mov    0x30(%r12),%edx
    1c3e:	49 63 04 24          	movslq (%r12),%rax
    1c42:	85 d2                	test   %edx,%edx
    1c44:	0f 85 fa 01 00 00    	jne    1e44 <polling_cq+0xbd4>
				rp = sink_pools[rh->nid];
    1c4a:	48 8b 04 c5 00 00 00 	mov    0x0(,%rax,8),%rax
    1c51:	00 
			rh->remote_sink_dma_addr = rp->addr;
    1c52:	48 8b 50 08          	mov    0x8(%rax),%rdx
			kfree(rw);
    1c56:	4c 89 ef             	mov    %r13,%rdi
			rh->remote_sink_dma_addr = rp->addr;
    1c59:	49 89 94 24 b8 00 00 	mov    %rdx,0xb8(%r12)
    1c60:	00 
			rh->remote_sink_size = rp->size;
    1c61:	48 8b 50 10          	mov    0x10(%rax),%rdx
    1c65:	49 89 94 24 c8 00 00 	mov    %rdx,0xc8(%r12)
    1c6c:	00 
			rh->sink_rkey = rp->rkey;
    1c6d:	8b 00                	mov    (%rax),%eax
    1c6f:	41 89 84 24 d4 00 00 	mov    %eax,0xd4(%r12)
    1c76:	00 
			kfree(rw);
    1c77:	e8 00 00 00 00       	callq  1c7c <polling_cq+0xa0c>
			DEBUG_LOG(PFX "recv sink addr %llx %x\n", rh->remote_sink_dma_addr, rh->sink_rkey);
    1c7c:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1c82 <polling_cq+0xa12>
    1c82:	85 c0                	test   %eax,%eax
    1c84:	0f 84 30 f6 ff ff    	je     12ba <polling_cq+0x4a>
    1c8a:	41 8b 94 24 d4 00 00 	mov    0xd4(%r12),%edx
    1c91:	00 
    1c92:	49 8b b4 24 b8 00 00 	mov    0xb8(%r12),%rsi
    1c99:	00 
    1c9a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1ca1:	e8 00 00 00 00       	callq  1ca6 <polling_cq+0xa36>
    1ca6:	e9 0f f6 ff ff       	jmpq   12ba <polling_cq+0x4a>
    1cab:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1cb2 <polling_cq+0xa42>
	if (dma_is_direct(ops))
    1cb2:	48 85 c0             	test   %rax,%rax
    1cb5:	0f 85 7d fb ff ff    	jne    1838 <polling_cq+0x5c8>
		dma_direct_unmap_page(dev, addr, size, dir, attrs);
    1cbb:	45 31 c0             	xor    %r8d,%r8d
    1cbe:	b9 02 00 00 00       	mov    $0x2,%ecx
    1cc3:	ba 18 00 00 00       	mov    $0x18,%edx
    1cc8:	e8 00 00 00 00       	callq  1ccd <polling_cq+0xa5d>
			if (rh->connection_type == CONNECTION_FETCH)
    1ccd:	41 8b 74 24 30       	mov    0x30(%r12),%esi
    1cd2:	49 63 04 24          	movslq (%r12),%rax
    1cd6:	85 f6                	test   %esi,%esi
    1cd8:	0f 85 73 01 00 00    	jne    1e51 <polling_cq+0xbe1>
				rp = rpc_pools[rh->nid];
    1cde:	48 8b 04 c5 00 00 00 	mov    0x0(,%rax,8),%rax
    1ce5:	00 
			rh->remote_rpc_dma_addr = rp->addr;
    1ce6:	48 8b 50 08          	mov    0x8(%rax),%rdx
			kfree(rw);
    1cea:	4c 89 ef             	mov    %r13,%rdi
			rh->remote_rpc_dma_addr = rp->addr;
    1ced:	49 89 94 24 b0 00 00 	mov    %rdx,0xb0(%r12)
    1cf4:	00 
			rh->remote_rpc_size = rp->size;
    1cf5:	48 8b 50 10          	mov    0x10(%rax),%rdx
    1cf9:	49 89 94 24 c0 00 00 	mov    %rdx,0xc0(%r12)
    1d00:	00 
			rh->rpc_rkey = rp->rkey;
    1d01:	8b 00                	mov    (%rax),%eax
    1d03:	41 89 84 24 d0 00 00 	mov    %eax,0xd0(%r12)
    1d0a:	00 
			kfree(rw);
    1d0b:	e8 00 00 00 00       	callq  1d10 <polling_cq+0xaa0>
			DEBUG_LOG(PFX "recv rpc addr %llx %x\n", rh->remote_rpc_dma_addr, rh->rpc_rkey);
    1d10:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 1d16 <polling_cq+0xaa6>
    1d16:	85 c9                	test   %ecx,%ecx
    1d18:	0f 84 9c f5 ff ff    	je     12ba <polling_cq+0x4a>
    1d1e:	41 8b 94 24 d0 00 00 	mov    0xd0(%r12),%edx
    1d25:	00 
    1d26:	49 8b b4 24 b0 00 00 	mov    0xb0(%r12),%rsi
    1d2d:	00 
    1d2e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1d35:	e8 00 00 00 00       	callq  1d3a <polling_cq+0xaca>
    1d3a:	e9 7b f5 ff ff       	jmpq   12ba <polling_cq+0x4a>
    1d3f:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1d46 <polling_cq+0xad6>
	if (dma_is_direct(ops))
    1d46:	48 85 c0             	test   %rax,%rax
    1d49:	0f 85 4f fb ff ff    	jne    189e <polling_cq+0x62e>
		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
    1d4f:	31 c9                	xor    %ecx,%ecx
    1d51:	ba 10 10 00 00       	mov    $0x1010,%edx
    1d56:	e8 00 00 00 00       	callq  1d5b <polling_cq+0xaeb>
	dest = (void *) *((uint64_t *) (rpc_buffer));
    1d5b:	49 8b 14 24          	mov    (%r12),%rdx
    1d5f:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	memcpy(dest, rpc_buffer + 8, PAGE_SIZE);
    1d64:	49 8d 74 24 08       	lea    0x8(%r12),%rsi
    1d69:	48 89 02             	mov    %rax,(%rdx)
    1d6c:	49 8b 84 24 00 10 00 	mov    0x1000(%r12),%rax
    1d73:	00 
    1d74:	48 8d 7a 08          	lea    0x8(%rdx),%rdi
    1d78:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1d7c:	48 89 82 f8 0f 00 00 	mov    %rax,0xff8(%rdx)
    1d83:	48 89 d0             	mov    %rdx,%rax
    1d86:	48 29 f8             	sub    %rdi,%rax
    1d89:	48 29 c6             	sub    %rax,%rsi
    1d8c:	05 00 10 00 00       	add    $0x1000,%eax
    1d91:	c1 e8 03             	shr    $0x3,%eax
    1d94:	89 c1                	mov    %eax,%ecx
    1d96:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	DEBUG_LOG(PFX "%s\n", (char *) dest);
    1d99:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 1d9f <polling_cq+0xb2f>
    1d9f:	85 c9                	test   %ecx,%ecx
    1da1:	0f 85 d8 01 00 00    	jne    1f7f <polling_cq+0xd0f>
	ret = ib_post_recv(rh->qp, &rw->wr, &bad_wr);
    1da7:	49 8b bf 40 01 00 00 	mov    0x140(%r15),%rdi
    1dae:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
	return qp->device->ops.post_recv(qp, recv_wr, bad_recv_wr ? : &dummy);
    1db5:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
    1db9:	48 8b 07             	mov    (%rdi),%rax
    1dbc:	48 83 c6 20          	add    $0x20,%rsi
    1dc0:	48 8b 40 10          	mov    0x10(%rax),%rax
    1dc4:	e8 00 00 00 00       	callq  1dc9 <polling_cq+0xb59>
	if (ret || bad_wr)  {
    1dc9:	85 c0                	test   %eax,%eax
    1dcb:	75 0b                	jne    1dd8 <polling_cq+0xb68>
    1dcd:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
    1dd2:	0f 84 e2 f4 ff ff    	je     12ba <polling_cq+0x4a>
		printk(KERN_ERR PFX "fail to post recv in %s\n", __func__);
    1dd8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1ddf:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1de6:	e8 00 00 00 00       	callq  1deb <polling_cq+0xb7b>
    1deb:	e9 ca f4 ff ff       	jmpq   12ba <polling_cq+0x4a>
    1df0:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1df7 <polling_cq+0xb87>
	if (dma_is_direct(ops))
    1df7:	48 85 c0             	test   %rax,%rax
    1dfa:	0f 85 b5 f9 ff ff    	jne    17b5 <polling_cq+0x545>
		dma_direct_unmap_page(dev, addr, size, dir, attrs);
    1e00:	45 31 c0             	xor    %r8d,%r8d
    1e03:	b9 01 00 00 00       	mov    $0x1,%ecx
    1e08:	ba 18 00 00 00       	mov    $0x18,%edx
    1e0d:	e8 00 00 00 00       	callq  1e12 <polling_cq+0xba2>
			kfree(sw);
    1e12:	4c 89 e7             	mov    %r12,%rdi
			rp = (struct pool_info *) sw->addr;
    1e15:	4d 8b 6c 24 50       	mov    0x50(%r12),%r13
			kfree(sw);
    1e1a:	e8 00 00 00 00       	callq  1e1f <polling_cq+0xbaf>
			DEBUG_LOG(PFX "send addr %llx completed\n", rp->addr);
    1e1f:	44 8b 1d 00 00 00 00 	mov    0x0(%rip),%r11d        # 1e26 <polling_cq+0xbb6>
    1e26:	45 85 db             	test   %r11d,%r11d
    1e29:	0f 84 8b f4 ff ff    	je     12ba <polling_cq+0x4a>
    1e2f:	49 8b 75 08          	mov    0x8(%r13),%rsi
    1e33:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1e3a:	e8 00 00 00 00       	callq  1e3f <polling_cq+0xbcf>
    1e3f:	e9 76 f4 ff ff       	jmpq   12ba <polling_cq+0x4a>
				rp = sink_pools_evic[rh->nid];
    1e44:	48 8b 04 c5 00 00 00 	mov    0x0(,%rax,8),%rax
    1e4b:	00 
    1e4c:	e9 01 fe ff ff       	jmpq   1c52 <polling_cq+0x9e2>
				rp = rpc_pools_evic[rh->nid];
    1e51:	48 8b 04 c5 00 00 00 	mov    0x0(,%rax,8),%rax
    1e58:	00 
    1e59:	e9 88 fe ff ff       	jmpq   1ce6 <polling_cq+0xa76>
    1e5e:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1e65 <polling_cq+0xbf5>
	if (dma_is_direct(ops))
    1e65:	48 85 c0             	test   %rax,%rax
    1e68:	0f 85 df fc ff ff    	jne    1b4d <polling_cq+0x8dd>
		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
    1e6e:	31 c9                	xor    %ecx,%ecx
    1e70:	ba 00 10 00 00       	mov    $0x1000,%edx
    1e75:	e8 00 00 00 00       	callq  1e7a <polling_cq+0xc0a>
    1e7a:	e9 e3 fc ff ff       	jmpq   1b62 <polling_cq+0x8f2>
    1e7f:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1e86 <polling_cq+0xc16>
	if (dma_is_direct(ops))
    1e86:	48 85 c0             	test   %rax,%rax
    1e89:	0f 85 98 fa ff ff    	jne    1927 <polling_cq+0x6b7>
		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
    1e8f:	4c 89 c2             	mov    %r8,%rdx
    1e92:	31 c9                	xor    %ecx,%ecx
    1e94:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    1e9b:	e8 00 00 00 00       	callq  1ea0 <polling_cq+0xc30>
    1ea0:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
    1ea7:	e9 9c fa ff ff       	jmpq   1948 <polling_cq+0x6d8>
    1eac:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1eb3 <polling_cq+0xc43>
	if (dma_is_direct(ops))
    1eb3:	48 85 c0             	test   %rax,%rax
    1eb6:	0f 85 e7 f5 ff ff    	jne    14a3 <polling_cq+0x233>
		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
    1ebc:	31 c9                	xor    %ecx,%ecx
    1ebe:	ba 10 00 00 00       	mov    $0x10,%edx
    1ec3:	e8 00 00 00 00       	callq  1ec8 <polling_cq+0xc58>
    1ec8:	e9 eb f5 ff ff       	jmpq   14b8 <polling_cq+0x248>
    1ecd:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1ed4 <polling_cq+0xc64>
	if (dma_is_direct(ops))
    1ed4:	48 85 c0             	test   %rax,%rax
    1ed7:	0f 85 e0 fb ff ff    	jne    1abd <polling_cq+0x84d>
		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
    1edd:	31 c9                	xor    %ecx,%ecx
    1edf:	ba 00 10 00 00       	mov    $0x1000,%edx
    1ee4:	4c 89 e6             	mov    %r12,%rsi
    1ee7:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    1eee:	e8 00 00 00 00       	callq  1ef3 <polling_cq+0xc83>
    1ef3:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
    1efa:	e9 e4 fb ff ff       	jmpq   1ae3 <polling_cq+0x873>
    1eff:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1f06 <polling_cq+0xc96>
	if (dma_is_direct(ops))
    1f06:	48 85 c0             	test   %rax,%rax
    1f09:	0f 85 60 f7 ff ff    	jne    166f <polling_cq+0x3ff>
		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
    1f0f:	31 c9                	xor    %ecx,%ecx
    1f11:	4c 89 ea             	mov    %r13,%rdx
    1f14:	4c 89 d6             	mov    %r10,%rsi
    1f17:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    1f1e:	e8 00 00 00 00       	callq  1f23 <polling_cq+0xcb3>
    1f23:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
    1f2a:	e9 64 f7 ff ff       	jmpq   1693 <polling_cq+0x423>
				printk(KERN_ERR PFX "cq completion failed with "
    1f2f:	44 8b 45 a0          	mov    -0x60(%rbp),%r8d
    1f33:	8b 4d 9c             	mov    -0x64(%rbp),%ecx
    1f36:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1f3d:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
    1f41:	e8 00 00 00 00       	callq  1f46 <polling_cq+0xcd6>
	return -1;
    1f46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
				goto error;
    1f4b:	e9 69 f4 ff ff       	jmpq   13b9 <polling_cq+0x149>
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, id, rw->wr.wr.ex.imm_data);
    1f50:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
    1f56:	44 89 ce             	mov    %r9d,%esi
    1f59:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1f60:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
    1f67:	e8 00 00 00 00       	callq  1f6c <polling_cq+0xcfc>
    1f6c:	4c 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%r8
    1f73:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
    1f7a:	e9 11 fb ff ff       	jmpq   1a90 <polling_cq+0x820>
	DEBUG_LOG(PFX "%s\n", (char *) dest);
    1f7f:	48 89 d6             	mov    %rdx,%rsi
    1f82:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1f89:	e8 00 00 00 00       	callq  1f8e <polling_cq+0xd1e>
    1f8e:	e9 14 fe ff ff       	jmpq   1da7 <polling_cq+0xb37>
					DEBUG_LOG(PFX "rdma write-imm completion\n");
    1f93:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1f9a:	e8 00 00 00 00       	callq  1f9f <polling_cq+0xd2f>
    1f9f:	e9 3d f8 ff ff       	jmpq   17e1 <polling_cq+0x571>
				DEBUG_LOG(PFX "send completion\n");
    1fa4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1fab:	e8 00 00 00 00       	callq  1fb0 <polling_cq+0xd40>
	sw = (struct send_work *) wc->wr_id;
    1fb0:	4c 8b 65 90          	mov    -0x70(%rbp),%r12
	switch (sw->work_type) {
    1fb4:	41 83 3c 24 04       	cmpl   $0x4,(%r12)
	dma_addr = sw->sgl.addr;
    1fb9:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
	rh = sw->rh;
    1fbe:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	switch (sw->work_type) {
    1fc3:	0f 84 c9 f7 ff ff    	je     1792 <polling_cq+0x522>
			DEBUG_LOG(PFX "error: unknown id\n");
    1fc9:	44 8b 15 00 00 00 00 	mov    0x0(%rip),%r10d        # 1fd0 <polling_cq+0xd60>
    1fd0:	45 85 d2             	test   %r10d,%r10d
    1fd3:	0f 84 e1 f2 ff ff    	je     12ba <polling_cq+0x4a>
    1fd9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1fe0:	e8 00 00 00 00       	callq  1fe5 <polling_cq+0xd75>
    1fe5:	e9 d0 f2 ff ff       	jmpq   12ba <polling_cq+0x4a>
				DEBUG_LOG(PFX "recv rpc\n");
    1fea:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1ff1:	e8 00 00 00 00       	callq  1ff6 <polling_cq+0xd86>
	DEBUG_LOG(PFX "%X\n", wc->ex.imm_data);
    1ff6:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1ffd <polling_cq+0xd8d>
	rw = (struct recv_work *) wc->wr_id;
    1ffd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
	const struct ib_recv_wr *bad_wr = NULL;
    2001:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    2008:	00 
    2009:	8b 75 b0             	mov    -0x50(%rbp),%esi
	rw = (struct recv_work *) wc->wr_id;
    200c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	rh = rw->rh;
    2013:	4c 8b 78 08          	mov    0x8(%rax),%r15
	DEBUG_LOG(PFX "%X\n", wc->ex.imm_data);
    2017:	0f 84 e9 f3 ff ff    	je     1406 <polling_cq+0x196>
    201d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2024:	e8 00 00 00 00       	callq  2029 <polling_cq+0xdb9>
	imm_data = be32_to_cpu(wc->ex.imm_data);
    2029:	8b 45 b0             	mov    -0x50(%rbp),%eax
    202c:	0f c8                	bswap  %eax
	offset = imm_data >> 16;
    202e:	41 89 c0             	mov    %eax,%r8d
	id = imm_data & 0x00007FFF;
    2031:	41 89 c5             	mov    %eax,%r13d
	op = (imm_data & 0x00008000) >> 15;
    2034:	c1 e8 0f             	shr    $0xf,%eax
    2037:	83 e0 01             	and    $0x1,%eax
	offset = imm_data >> 16;
    203a:	41 c1 e8 10          	shr    $0x10,%r8d
	id = imm_data & 0x00007FFF;
    203e:	66 41 81 e5 ff 7f    	and    $0x7fff,%r13w
	DEBUG_LOG(PFX "offset: %d, id: %d op: %d\n", offset, id, op);
    2044:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 204b <polling_cq+0xddb>
	op = (imm_data & 0x00008000) >> 15;
    204b:	41 89 c1             	mov    %eax,%r9d
	DEBUG_LOG(PFX "offset: %d, id: %d op: %d\n", offset, id, op);
    204e:	0f 84 cd f3 ff ff    	je     1421 <polling_cq+0x1b1>
    2054:	44 89 c6             	mov    %r8d,%esi
    2057:	41 0f b7 d5          	movzwl %r13w,%edx
    205b:	89 c1                	mov    %eax,%ecx
    205d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2064:	44 89 85 70 ff ff ff 	mov    %r8d,-0x90(%rbp)
    206b:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
    2071:	e8 00 00 00 00       	callq  2076 <polling_cq+0xe06>
    2076:	44 8b 8d 6c ff ff ff 	mov    -0x94(%rbp),%r9d
    207d:	44 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8d
    2084:	e9 98 f3 ff ff       	jmpq   1421 <polling_cq+0x1b1>
}
    2089:	e8 00 00 00 00       	callq  208e <polling_cq+0xe1e>
	DEBUG_LOG(PFX "allocating addr %llx\n", (uint64_t) my_data);
    208e:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2095 <polling_cq+0xe25>
    2095:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    209c:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    20a3:	e8 00 00 00 00       	callq  20a8 <polling_cq+0xe38>
    20a8:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
    20af:	e9 3f fa ff ff       	jmpq   1af3 <polling_cq+0x883>
				DEBUG_LOG(PFX "recv completion\n");
    20b4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    20bb:	e8 00 00 00 00       	callq  20c0 <polling_cq+0xe50>
	rw = (struct recv_work *) wc->wr_id;
    20c0:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
	switch (rw->work_type) {
    20c4:	41 8b 45 00          	mov    0x0(%r13),%eax
	rh = rw->rh;
    20c8:	4d 8b 65 08          	mov    0x8(%r13),%r12
	switch (rw->work_type) {
    20cc:	83 f8 01             	cmp    $0x1,%eax
    20cf:	0f 84 3b f7 ff ff    	je     1810 <polling_cq+0x5a0>
    20d5:	83 f8 02             	cmp    $0x2,%eax
    20d8:	0f 85 eb fe ff ff    	jne    1fc9 <polling_cq+0xd59>
    20de:	e9 19 f6 ff ff       	jmpq   16fc <polling_cq+0x48c>
	DEBUG_LOG(PFX "Polling thread now running\n");
    20e3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    20ea:	e8 00 00 00 00       	callq  20ef <polling_cq+0xe7f>
    20ef:	e9 c6 f1 ff ff       	jmpq   12ba <polling_cq+0x4a>
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, id, rw->wr.wr.ex.imm_data);
    20f4:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
    20fa:	44 89 ce             	mov    %r9d,%esi
    20fd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2104:	4c 89 85 58 ff ff ff 	mov    %r8,-0xa8(%rbp)
    210b:	e8 00 00 00 00       	callq  2110 <polling_cq+0xea0>
    2110:	4c 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%r8
    2117:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
    211e:	e9 e9 f4 ff ff       	jmpq   160c <polling_cq+0x39c>
	DEBUG_LOG(PFX "dest: %llx order: %u num_page: %d\n", (uint64_t) dest, order, num_page);
    2123:	8b 95 58 ff ff ff    	mov    -0xa8(%rbp),%edx
    2129:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
    2130:	44 89 e9             	mov    %r13d,%ecx
    2133:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    213a:	e8 00 00 00 00       	callq  213f <polling_cq+0xecf>
    213f:	48 89 9d 50 ff ff ff 	mov    %rbx,-0xb0(%rbp)
    2146:	48 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%rbx
    214d:	e9 b1 f3 ff ff       	jmpq   1503 <polling_cq+0x293>
    2152:	0f 1f 40 00          	nopl   0x0(%rax)
    2156:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    215d:	00 00 00 

0000000000002160 <rmm_alloc>:
{
    2160:	e8 00 00 00 00       	callq  2165 <rmm_alloc+0x5>
    2165:	55                   	push   %rbp
	struct rdma_handle *rh = rdma_handles[nid];	
    2166:	48 63 ff             	movslq %edi,%rdi
{
    2169:	48 89 e5             	mov    %rsp,%rbp
    216c:	41 57                	push   %r15
    216e:	41 56                	push   %r14
    2170:	41 55                	push   %r13
    2172:	41 54                	push   %r12
    2174:	53                   	push   %rbx
    2175:	48 83 ec 18          	sub    $0x18,%rsp
	struct rdma_handle *rh = rdma_handles[nid];	
    2179:	4c 8b 2c fd 00 00 00 	mov    0x0(,%rdi,8),%r13
    2180:	00 
	const struct ib_send_wr *bad_wr = NULL;
    2181:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    2188:	00 
    2189:	49 8d 9d f8 00 00 00 	lea    0xf8(%r13),%rbx
    2190:	4d 8d b5 d8 00 00 00 	lea    0xd8(%r13),%r14
    2197:	eb 0c                	jmp    21a5 <rmm_alloc+0x45>
    2199:	48 89 df             	mov    %rbx,%rdi
    219c:	ff 14 25 00 00 00 00 	callq  *0x0
    21a3:	0f 0b                	ud2    
    21a5:	48 89 df             	mov    %rbx,%rdi
    21a8:	e8 00 00 00 00       	callq  21ad <rmm_alloc+0x4d>
		i = find_first_zero_bit(rh->rpc_slots, NR_RPC_SLOTS);
    21ad:	be 00 01 00 00       	mov    $0x100,%esi
    21b2:	4c 89 f7             	mov    %r14,%rdi
    21b5:	e8 00 00 00 00       	callq  21ba <rmm_alloc+0x5a>
		if (i < NR_RPC_SLOTS) break;
    21ba:	3d ff 00 00 00       	cmp    $0xff,%eax
		i = find_first_zero_bit(rh->rpc_slots, NR_RPC_SLOTS);
    21bf:	49 89 c4             	mov    %rax,%r12
		if (i < NR_RPC_SLOTS) break;
    21c2:	77 d5                	ja     2199 <rmm_alloc+0x39>
	set_bit(i, rh->rpc_slots);
    21c4:	4c 63 f0             	movslq %eax,%r14
		asm volatile(LOCK_PREFIX __ASM_SIZE(bts) " %1,%0"
    21c7:	f0 4d 0f ab b5 d8 00 	lock bts %r14,0xd8(%r13)
    21ce:	00 00 
    21d0:	48 89 df             	mov    %rbx,%rdi
    21d3:	ff 14 25 00 00 00 00 	callq  *0x0
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    21da:	44 89 e1             	mov    %r12d,%ecx
    21dd:	4d 8b 55 48          	mov    0x48(%r13),%r10
	rpc_dma_addr = rh->rpc_dma_addr + (i * RPC_ARGS_SIZE);
    21e1:	4d 8b 4d 70          	mov    0x70(%r13),%r9
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    21e5:	c1 e1 04             	shl    $0x4,%ecx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    21e8:	45 8b 85 d0 00 00 00 	mov    0xd0(%r13),%r8d
    21ef:	ba 10 00 00 00       	mov    $0x10,%edx
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    21f4:	48 63 c9             	movslq %ecx,%rcx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    21f7:	4c 89 ef             	mov    %r13,%rdi
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id | 0x8000);
    21fa:	41 c1 e4 10          	shl    $0x10,%r12d
	rpc_dma_addr = rh->rpc_dma_addr + (i * RPC_ARGS_SIZE);
    21fe:	49 01 c9             	add    %rcx,%r9
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    2201:	49 01 ca             	add    %rcx,%r10
	remote_rpc_dma_addr = rh->remote_rpc_dma_addr + (i * RPC_ARGS_SIZE);
    2204:	49 03 8d b0 00 00 00 	add    0xb0(%r13),%rcx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    220b:	4c 89 ce             	mov    %r9,%rsi
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    220e:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    2212:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
    2216:	e8 e5 dd ff ff       	callq  0 <__get_rdma_work>
    221b:	49 89 c7             	mov    %rax,%r15
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id | 0x8000);
    221e:	0f b6 00             	movzbl (%rax),%eax
	rw->addr = rpc_buffer;
    2221:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
	rw->dma_addr = rpc_dma_addr;
    2225:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
	rw->work_type = WORK_TYPE_RPC;
    2229:	41 c7 47 04 05 00 00 	movl   $0x5,0x4(%r15)
    2230:	00 
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    2231:	49 8d 77 28          	lea    0x28(%r15),%rsi
	rw->done = false;
    2235:	41 c6 47 60 00       	movb   $0x0,0x60(%r15)
	return qp->device->ops.post_send(qp, send_wr, bad_send_wr ? : &dummy);
    223a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
	rw->addr = rpc_buffer;
    223e:	4d 89 57 68          	mov    %r10,0x68(%r15)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id | 0x8000);
    2242:	41 09 c4             	or     %eax,%r12d
	rw->dma_addr = rpc_dma_addr;
    2245:	4d 89 4f 70          	mov    %r9,0x70(%r15)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id | 0x8000);
    2249:	41 81 cc 00 80 00 00 	or     $0x8000,%r12d
    2250:	41 0f cc             	bswap  %r12d
    2253:	45 89 67 4c          	mov    %r12d,0x4c(%r15)
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    2257:	49 8b bd 40 01 00 00 	mov    0x140(%r13),%rdi
    225e:	48 8b 07             	mov    (%rdi),%rax
    2261:	48 8b 40 08          	mov    0x8(%rax),%rax
    2265:	e8 00 00 00 00       	callq  226a <rmm_alloc+0x10a>
	if (ret || bad_wr) {
    226a:	85 c0                	test   %eax,%eax
    226c:	41 89 c4             	mov    %eax,%r12d
    226f:	75 60                	jne    22d1 <rmm_alloc+0x171>
    2271:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    2276:	75 59                	jne    22d1 <rmm_alloc+0x171>
	DEBUG_LOG(PFX "wait %p\n", rw);
    2278:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 227e <rmm_alloc+0x11e>
    227e:	85 c0                	test   %eax,%eax
    2280:	0f 85 86 00 00 00    	jne    230c <rmm_alloc+0x1ac>
	} while(!(done_copy = rw->done));
    2286:	41 80 7f 60 00       	cmpb   $0x0,0x60(%r15)
    228b:	74 f9                	je     2286 <rmm_alloc+0x126>
	DEBUG_LOG(PFX "alloc done %s\n", my_data);
    228d:	44 8b 25 00 00 00 00 	mov    0x0(%rip),%r12d        # 2294 <rmm_alloc+0x134>
    2294:	45 85 e4             	test   %r12d,%r12d
    2297:	75 5b                	jne    22f4 <rmm_alloc+0x194>
    2299:	48 89 df             	mov    %rbx,%rdi
    229c:	e8 00 00 00 00       	callq  22a1 <rmm_alloc+0x141>
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
			: "iq" ((u8)~CONST_MASK(nr)));
	} else {
		asm volatile(LOCK_PREFIX __ASM_SIZE(btr) " %1,%0"
    22a1:	f0 4d 0f b3 b5 d8 00 	lock btr %r14,0xd8(%r13)
    22a8:	00 00 
    22aa:	48 89 df             	mov    %rbx,%rdi
    22ad:	ff 14 25 00 00 00 00 	callq  *0x0
	__put_rdma_work(rh, rw);
    22b4:	4c 89 fe             	mov    %r15,%rsi
    22b7:	4c 89 ef             	mov    %r13,%rdi
    22ba:	e8 81 de ff ff       	callq  140 <__put_rdma_work>
}
    22bf:	48 83 c4 18          	add    $0x18,%rsp
    22c3:	44 89 e0             	mov    %r12d,%eax
    22c6:	5b                   	pop    %rbx
    22c7:	41 5c                	pop    %r12
    22c9:	41 5d                	pop    %r13
    22cb:	41 5e                	pop    %r14
    22cd:	41 5f                	pop    %r15
    22cf:	5d                   	pop    %rbp
    22d0:	c3                   	retq   
		printk(KERN_ERR PFX "Cannot post send wr, %d %p\n", ret, bad_wr);
    22d1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    22d5:	44 89 e6             	mov    %r12d,%esi
    22d8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    22df:	e8 00 00 00 00       	callq  22e4 <rmm_alloc+0x184>
    22e4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    22e9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    22ee:	44 0f 45 e0          	cmovne %eax,%r12d
    22f2:	eb a5                	jmp    2299 <rmm_alloc+0x139>
	DEBUG_LOG(PFX "alloc done %s\n", my_data);
    22f4:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 22fb <rmm_alloc+0x19b>
    22fb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    2302:	45 31 e4             	xor    %r12d,%r12d
	DEBUG_LOG(PFX "alloc done %s\n", my_data);
    2305:	e8 00 00 00 00       	callq  230a <rmm_alloc+0x1aa>
    230a:	eb 8d                	jmp    2299 <rmm_alloc+0x139>
	DEBUG_LOG(PFX "wait %p\n", rw);
    230c:	4c 89 fe             	mov    %r15,%rsi
    230f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2316:	e8 00 00 00 00       	callq  231b <rmm_alloc+0x1bb>
    231b:	e9 66 ff ff ff       	jmpq   2286 <rmm_alloc+0x126>

0000000000002320 <rmm_fetch>:
{
    2320:	e8 00 00 00 00       	callq  2325 <rmm_fetch+0x5>
    2325:	55                   	push   %rbp
	struct rdma_handle *rh = rdma_handles[nid];	
    2326:	48 63 ff             	movslq %edi,%rdi
{
    2329:	48 89 e5             	mov    %rsp,%rbp
    232c:	41 57                	push   %r15
    232e:	41 56                	push   %r14
    2330:	41 55                	push   %r13
    2332:	41 54                	push   %r12
    2334:	53                   	push   %rbx
    2335:	48 83 ec 30          	sub    $0x30,%rsp
	struct rdma_handle *rh = rdma_handles[nid];	
    2339:	4c 8b 24 fd 00 00 00 	mov    0x0(,%rdi,8),%r12
    2340:	00 
{
    2341:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    2345:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    2349:	89 4d bc             	mov    %ecx,-0x44(%rbp)
	const struct ib_send_wr *bad_wr = NULL;
    234c:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    2353:	00 
    2354:	49 8d 9c 24 f8 00 00 	lea    0xf8(%r12),%rbx
    235b:	00 
    235c:	4d 8d ac 24 d8 00 00 	lea    0xd8(%r12),%r13
    2363:	00 
    2364:	eb 0c                	jmp    2372 <rmm_fetch+0x52>
    2366:	48 89 df             	mov    %rbx,%rdi
    2369:	ff 14 25 00 00 00 00 	callq  *0x0
    2370:	0f 0b                	ud2    
    2372:	48 89 df             	mov    %rbx,%rdi
    2375:	e8 00 00 00 00       	callq  237a <rmm_fetch+0x5a>
		i = find_first_zero_bit(rh->rpc_slots, NR_RPC_SLOTS);
    237a:	be 00 01 00 00       	mov    $0x100,%esi
    237f:	4c 89 ef             	mov    %r13,%rdi
    2382:	e8 00 00 00 00       	callq  2387 <rmm_fetch+0x67>
		if (i < NR_RPC_SLOTS) break;
    2387:	3d ff 00 00 00       	cmp    $0xff,%eax
		i = find_first_zero_bit(rh->rpc_slots, NR_RPC_SLOTS);
    238c:	49 89 c1             	mov    %rax,%r9
		if (i < NR_RPC_SLOTS) break;
    238f:	77 d5                	ja     2366 <rmm_fetch+0x46>
	set_bit(i, rh->rpc_slots);
    2391:	4c 63 e8             	movslq %eax,%r13
		asm volatile(LOCK_PREFIX __ASM_SIZE(bts) " %1,%0"
    2394:	f0 4d 0f ab ac 24 d8 	lock bts %r13,0xd8(%r12)
    239b:	00 00 00 
    239e:	48 89 df             	mov    %rbx,%rdi
    23a1:	ff 14 25 00 00 00 00 	callq  *0x0
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    23a8:	44 89 c9             	mov    %r9d,%ecx
    23ab:	4d 8b 74 24 48       	mov    0x48(%r12),%r14
	rpc_dma_addr = rh->rpc_dma_addr + (i * RPC_ARGS_SIZE);
    23b0:	4d 8b 5c 24 70       	mov    0x70(%r12),%r11
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    23b5:	c1 e1 04             	shl    $0x4,%ecx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    23b8:	45 8b 84 24 d0 00 00 	mov    0xd0(%r12),%r8d
    23bf:	00 
    23c0:	ba 10 00 00 00       	mov    $0x10,%edx
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    23c5:	48 63 c9             	movslq %ecx,%rcx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    23c8:	4c 89 e7             	mov    %r12,%rdi
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    23cb:	4c 89 4d a8          	mov    %r9,-0x58(%rbp)
	rpc_dma_addr = rh->rpc_dma_addr + (i * RPC_ARGS_SIZE);
    23cf:	49 01 cb             	add    %rcx,%r11
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * RPC_ARGS_SIZE);
    23d2:	49 01 ce             	add    %rcx,%r14
	remote_rpc_dma_addr = rh->remote_rpc_dma_addr + (i * RPC_ARGS_SIZE);
    23d5:	49 03 8c 24 b0 00 00 	add    0xb0(%r12),%rcx
    23dc:	00 
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    23dd:	4c 89 de             	mov    %r11,%rsi
    23e0:	4c 89 5d b0          	mov    %r11,-0x50(%rbp)
    23e4:	e8 17 dc ff ff       	callq  0 <__get_rdma_work>
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    23e9:	4c 8b 4d a8          	mov    -0x58(%rbp),%r9
    23ed:	0f b6 10             	movzbl (%rax),%edx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    23f0:	49 89 c7             	mov    %rax,%r15
	rw->dma_addr = rpc_dma_addr;
    23f3:	4c 8b 5d b0          	mov    -0x50(%rbp),%r11
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    23f7:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 23fd <rmm_fetch+0xdd>
	rw->work_type = WORK_TYPE_RPC;
    23fd:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%rax)
	rw->addr = rpc_buffer;
    2404:	4c 89 70 68          	mov    %r14,0x68(%rax)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    2408:	44 89 c9             	mov    %r9d,%ecx
	rw->done = false;
    240b:	c6 40 60 00          	movb   $0x0,0x60(%rax)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    240f:	c1 e1 10             	shl    $0x10,%ecx
	rw->dma_addr = rpc_dma_addr;
    2412:	4c 89 58 70          	mov    %r11,0x70(%rax)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    2416:	09 d1                	or     %edx,%ecx
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    2418:	85 f6                	test   %esi,%esi
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    241a:	0f c9                	bswap  %ecx
    241c:	89 48 4c             	mov    %ecx,0x4c(%rax)
	rw->src = src;
    241f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    2423:	49 89 87 80 00 00 00 	mov    %rax,0x80(%r15)
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    242a:	0f 85 11 01 00 00    	jne    2541 <rmm_fetch+0x221>
	*((uint64_t *) (rpc_buffer)) = (uint64_t) vaddr;
    2430:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    2434:	49 89 06             	mov    %rax,(%r14)
	*((uint64_t *) (rpc_buffer + 8)) = order;
    2437:	8b 45 bc             	mov    -0x44(%rbp),%eax
    243a:	49 89 46 08          	mov    %rax,0x8(%r14)
	ib_dma_sync_single_for_device(rh->device, rpc_dma_addr, RPC_ARGS_SIZE, DMA_BIDIRECTIONAL);
    243e:	49 8b 84 24 30 01 00 	mov    0x130(%r12),%rax
    2445:	00 
    2446:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    2449:	48 85 ff             	test   %rdi,%rdi
    244c:	74 26                	je     2474 <rmm_fetch+0x154>
    244e:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    2455:	48 85 c0             	test   %rax,%rax
    2458:	74 1a                	je     2474 <rmm_fetch+0x154>
	else if (ops->sync_single_for_device)
    245a:	48 8b 40 58          	mov    0x58(%rax),%rax
    245e:	48 85 c0             	test   %rax,%rax
    2461:	74 2c                	je     248f <rmm_fetch+0x16f>
		ops->sync_single_for_device(dev, addr, size, dir);
    2463:	31 c9                	xor    %ecx,%ecx
    2465:	ba 10 00 00 00       	mov    $0x10,%edx
    246a:	4c 89 de             	mov    %r11,%rsi
    246d:	e8 00 00 00 00       	callq  2472 <rmm_fetch+0x152>
    2472:	eb 1b                	jmp    248f <rmm_fetch+0x16f>
    2474:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 247b <rmm_fetch+0x15b>
	if (dma_is_direct(ops))
    247b:	48 85 c0             	test   %rax,%rax
    247e:	75 da                	jne    245a <rmm_fetch+0x13a>
		dma_direct_sync_single_for_device(dev, addr, size, dir);
    2480:	31 c9                	xor    %ecx,%ecx
    2482:	ba 10 00 00 00       	mov    $0x10,%edx
    2487:	4c 89 de             	mov    %r11,%rsi
    248a:	e8 00 00 00 00       	callq  248f <rmm_fetch+0x16f>
	DEBUG_LOG(PFX "vaddr: %llX %llX\n", (uint64_t) vaddr, *((uint64_t *) (rpc_buffer)));
    248f:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 2495 <rmm_fetch+0x175>
    2495:	85 d2                	test   %edx,%edx
    2497:	0f 85 8c 00 00 00    	jne    2529 <rmm_fetch+0x209>
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    249d:	49 8b bc 24 40 01 00 	mov    0x140(%r12),%rdi
    24a4:	00 
    24a5:	49 8d 77 28          	lea    0x28(%r15),%rsi
    24a9:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
    24ad:	48 8b 07             	mov    (%rdi),%rax
    24b0:	48 8b 40 08          	mov    0x8(%rax),%rax
    24b4:	e8 00 00 00 00       	callq  24b9 <rmm_fetch+0x199>
	if (ret || bad_wr) {
    24b9:	85 c0                	test   %eax,%eax
    24bb:	41 89 c6             	mov    %eax,%r14d
    24be:	0f 85 c8 00 00 00    	jne    258c <rmm_fetch+0x26c>
    24c4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    24c9:	0f 85 bd 00 00 00    	jne    258c <rmm_fetch+0x26c>
	DEBUG_LOG(PFX "wait %p\n", rw);
    24cf:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 24d5 <rmm_fetch+0x1b5>
    24d5:	85 c0                	test   %eax,%eax
    24d7:	0f 85 9b 00 00 00    	jne    2578 <rmm_fetch+0x258>
	} while(!(done_copy = rw->done));
    24dd:	41 80 7f 60 00       	cmpb   $0x0,0x60(%r15)
    24e2:	74 f9                	je     24dd <rmm_fetch+0x1bd>
	DEBUG_LOG(PFX "reclaim done %s\n", my_data);
    24e4:	44 8b 35 00 00 00 00 	mov    0x0(%rip),%r14d        # 24eb <rmm_fetch+0x1cb>
    24eb:	45 85 f6             	test   %r14d,%r14d
    24ee:	75 6d                	jne    255d <rmm_fetch+0x23d>
    24f0:	48 89 df             	mov    %rbx,%rdi
    24f3:	e8 00 00 00 00       	callq  24f8 <rmm_fetch+0x1d8>
		asm volatile(LOCK_PREFIX __ASM_SIZE(btr) " %1,%0"
    24f8:	f0 4d 0f b3 ac 24 d8 	lock btr %r13,0xd8(%r12)
    24ff:	00 00 00 
    2502:	48 89 df             	mov    %rbx,%rdi
    2505:	ff 14 25 00 00 00 00 	callq  *0x0
	__put_rdma_work(rh, rw);
    250c:	4c 89 fe             	mov    %r15,%rsi
    250f:	4c 89 e7             	mov    %r12,%rdi
    2512:	e8 29 dc ff ff       	callq  140 <__put_rdma_work>
}
    2517:	48 83 c4 30          	add    $0x30,%rsp
    251b:	44 89 f0             	mov    %r14d,%eax
    251e:	5b                   	pop    %rbx
    251f:	41 5c                	pop    %r12
    2521:	41 5d                	pop    %r13
    2523:	41 5e                	pop    %r14
    2525:	41 5f                	pop    %r15
    2527:	5d                   	pop    %rbp
    2528:	c3                   	retq   
	DEBUG_LOG(PFX "vaddr: %llX %llX\n", (uint64_t) vaddr, *((uint64_t *) (rpc_buffer)));
    2529:	49 8b 16             	mov    (%r14),%rdx
    252c:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    2530:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2537:	e8 00 00 00 00       	callq  253c <rmm_fetch+0x21c>
    253c:	e9 5c ff ff ff       	jmpq   249d <rmm_fetch+0x17d>
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    2541:	44 89 ce             	mov    %r9d,%esi
    2544:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    254b:	4c 89 5d c0          	mov    %r11,-0x40(%rbp)
    254f:	e8 00 00 00 00       	callq  2554 <rmm_fetch+0x234>
    2554:	4c 8b 5d c0          	mov    -0x40(%rbp),%r11
    2558:	e9 d3 fe ff ff       	jmpq   2430 <rmm_fetch+0x110>
	DEBUG_LOG(PFX "reclaim done %s\n", my_data);
    255d:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2564 <rmm_fetch+0x244>
    2564:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    256b:	45 31 f6             	xor    %r14d,%r14d
	DEBUG_LOG(PFX "reclaim done %s\n", my_data);
    256e:	e8 00 00 00 00       	callq  2573 <rmm_fetch+0x253>
    2573:	e9 78 ff ff ff       	jmpq   24f0 <rmm_fetch+0x1d0>
	DEBUG_LOG(PFX "wait %p\n", rw);
    2578:	4c 89 fe             	mov    %r15,%rsi
    257b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2582:	e8 00 00 00 00       	callq  2587 <rmm_fetch+0x267>
    2587:	e9 51 ff ff ff       	jmpq   24dd <rmm_fetch+0x1bd>
		printk(KERN_ERR PFX "Cannot post send wr, %d %p\n", ret, bad_wr);
    258c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    2590:	44 89 f6             	mov    %r14d,%esi
    2593:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    259a:	e8 00 00 00 00       	callq  259f <rmm_fetch+0x27f>
    259f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    25a4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    25a9:	44 0f 45 f0          	cmovne %eax,%r14d
    25ad:	e9 3e ff ff ff       	jmpq   24f0 <rmm_fetch+0x1d0>
    25b2:	0f 1f 40 00          	nopl   0x0(%rax)
    25b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    25bd:	00 00 00 

00000000000025c0 <rmm_evict>:
{
    25c0:	e8 00 00 00 00       	callq  25c5 <rmm_evict+0x5>
    25c5:	55                   	push   %rbp
	struct rdma_handle *rh = rdma_handles_evic[nid];	
    25c6:	48 63 ff             	movslq %edi,%rdi
{
    25c9:	48 89 e5             	mov    %rsp,%rbp
    25cc:	41 57                	push   %r15
    25ce:	41 56                	push   %r14
    25d0:	41 55                	push   %r13
    25d2:	41 54                	push   %r12
    25d4:	49 89 d5             	mov    %rdx,%r13
    25d7:	53                   	push   %rbx
    25d8:	48 83 ec 28          	sub    $0x28,%rsp
	struct rdma_handle *rh = rdma_handles_evic[nid];	
    25dc:	4c 8b 24 fd 00 00 00 	mov    0x0(,%rdi,8),%r12
    25e3:	00 
{
    25e4:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	const struct ib_send_wr *bad_wr = NULL;
    25e8:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    25ef:	00 
    25f0:	49 8d 9c 24 f8 00 00 	lea    0xf8(%r12),%rbx
    25f7:	00 
    25f8:	4d 8d b4 24 d8 00 00 	lea    0xd8(%r12),%r14
    25ff:	00 
    2600:	eb 0c                	jmp    260e <rmm_evict+0x4e>
    2602:	48 89 df             	mov    %rbx,%rdi
    2605:	ff 14 25 00 00 00 00 	callq  *0x0
    260c:	0f 0b                	ud2    
    260e:	48 89 df             	mov    %rbx,%rdi
    2611:	e8 00 00 00 00       	callq  2616 <rmm_evict+0x56>
		i = find_first_zero_bit(rh->rpc_slots, NR_RPC_SLOTS);
    2616:	be 00 01 00 00       	mov    $0x100,%esi
    261b:	4c 89 f7             	mov    %r14,%rdi
    261e:	e8 00 00 00 00       	callq  2623 <rmm_evict+0x63>
		if (i < NR_RPC_SLOTS) break;
    2623:	3d ff 00 00 00       	cmp    $0xff,%eax
    2628:	77 d8                	ja     2602 <rmm_evict+0x42>
	set_bit(i, rh->rpc_slots);
    262a:	4c 63 f0             	movslq %eax,%r14
    262d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		asm volatile(LOCK_PREFIX __ASM_SIZE(bts) " %1,%0"
    2631:	f0 4d 0f ab b4 24 d8 	lock bts %r14,0xd8(%r12)
    2638:	00 00 00 
    263b:	48 89 df             	mov    %rbx,%rdi
    263e:	ff 14 25 00 00 00 00 	callq  *0x0
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    2645:	4c 89 f1             	mov    %r14,%rcx
    2648:	4d 8b 54 24 48       	mov    0x48(%r12),%r10
	rpc_dma_addr = rh->rpc_dma_addr + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    264d:	4d 8b 5c 24 70       	mov    0x70(%r12),%r11
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    2652:	48 c1 e1 08          	shl    $0x8,%rcx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE + PAGE_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    2656:	45 8b 84 24 d0 00 00 	mov    0xd0(%r12),%r8d
    265d:	00 
    265e:	ba 10 10 00 00       	mov    $0x1010,%edx
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    2663:	4c 01 f1             	add    %r14,%rcx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE + PAGE_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    2666:	4c 89 e7             	mov    %r12,%rdi
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    2669:	48 c1 e1 04          	shl    $0x4,%rcx
	rpc_dma_addr = rh->rpc_dma_addr + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    266d:	49 01 cb             	add    %rcx,%r11
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    2670:	49 01 ca             	add    %rcx,%r10
	remote_rpc_dma_addr = rh->remote_rpc_dma_addr + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    2673:	49 03 8c 24 b0 00 00 	add    0xb0(%r12),%rcx
    267a:	00 
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE + PAGE_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    267b:	4c 89 de             	mov    %r11,%rsi
	rpc_buffer = ((uint8_t *) rh->rpc_buffer) + (i * (RPC_ARGS_SIZE + PAGE_SIZE));
    267e:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE + PAGE_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    2682:	4c 89 5d c0          	mov    %r11,-0x40(%rbp)
    2686:	e8 75 d9 ff ff       	callq  0 <__get_rdma_work>
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    268b:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
    268f:	0f b6 10             	movzbl (%rax),%edx
	rw = __get_rdma_work(rh, rpc_dma_addr, RPC_ARGS_SIZE + PAGE_SIZE, remote_rpc_dma_addr, rh->rpc_rkey);
    2692:	49 89 c7             	mov    %rax,%r15
	rw->addr = rpc_buffer;
    2695:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
	rw->dma_addr = rpc_dma_addr;
    2699:	4c 8b 5d c0          	mov    -0x40(%rbp),%r11
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    269d:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 26a3 <rmm_evict+0xe3>
	rw->work_type = WORK_TYPE_RPC;
    26a3:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%rax)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    26aa:	44 89 c9             	mov    %r9d,%ecx
	rw->done = false;
    26ad:	c6 40 60 00          	movb   $0x0,0x60(%rax)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    26b1:	c1 e1 10             	shl    $0x10,%ecx
	rw->addr = rpc_buffer;
    26b4:	4c 89 50 68          	mov    %r10,0x68(%rax)
	rw->dma_addr = rpc_dma_addr;
    26b8:	4c 89 58 70          	mov    %r11,0x70(%rax)
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    26bc:	09 d1                	or     %edx,%ecx
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    26be:	85 f6                	test   %esi,%esi
	rw->wr.wr.ex.imm_data = cpu_to_be32((i << 16) | rw->id);
    26c0:	0f c9                	bswap  %ecx
    26c2:	89 48 4c             	mov    %ecx,0x4c(%rax)
	rw->src = r_vaddr;
    26c5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    26c9:	49 89 87 80 00 00 00 	mov    %rax,0x80(%r15)
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    26d0:	0f 85 3a 01 00 00    	jne    2810 <rmm_evict+0x250>
	*((uint64_t *) (rpc_buffer)) = (uint64_t) r_vaddr;
    26d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    26da:	49 8d 7a 10          	lea    0x10(%r10),%rdi
	memcpy(rpc_buffer + 8, l_vaddr, PAGE_SIZE);
    26de:	49 8d 4a 08          	lea    0x8(%r10),%rcx
    26e2:	4c 89 ee             	mov    %r13,%rsi
    26e5:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
	*((uint64_t *) (rpc_buffer)) = (uint64_t) r_vaddr;
    26e9:	49 89 02             	mov    %rax,(%r10)
    26ec:	49 8b 45 00          	mov    0x0(%r13),%rax
    26f0:	48 29 f9             	sub    %rdi,%rcx
    26f3:	48 29 ce             	sub    %rcx,%rsi
    26f6:	81 c1 00 10 00 00    	add    $0x1000,%ecx
    26fc:	c1 e9 03             	shr    $0x3,%ecx
    26ff:	49 89 42 08          	mov    %rax,0x8(%r10)
    2703:	49 8b 85 f8 0f 00 00 	mov    0xff8(%r13),%rax
    270a:	49 89 82 00 10 00 00 	mov    %rax,0x1000(%r10)
    2711:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	ib_dma_sync_single_for_device(rh->device, rpc_dma_addr, RPC_ARGS_SIZE + PAGE_SIZE, DMA_BIDIRECTIONAL);
    2714:	49 8b 84 24 30 01 00 	mov    0x130(%r12),%rax
    271b:	00 
    271c:	48 8b 38             	mov    (%rax),%rdi
	if (dev && dev->dma_ops)
    271f:	48 85 ff             	test   %rdi,%rdi
    2722:	74 26                	je     274a <rmm_evict+0x18a>
    2724:	48 8b 87 28 02 00 00 	mov    0x228(%rdi),%rax
    272b:	48 85 c0             	test   %rax,%rax
    272e:	74 1a                	je     274a <rmm_evict+0x18a>
	else if (ops->sync_single_for_device)
    2730:	48 8b 40 58          	mov    0x58(%rax),%rax
    2734:	48 85 c0             	test   %rax,%rax
    2737:	74 2c                	je     2765 <rmm_evict+0x1a5>
		ops->sync_single_for_device(dev, addr, size, dir);
    2739:	31 c9                	xor    %ecx,%ecx
    273b:	ba 10 10 00 00       	mov    $0x1010,%edx
    2740:	4c 89 de             	mov    %r11,%rsi
    2743:	e8 00 00 00 00       	callq  2748 <rmm_evict+0x188>
    2748:	eb 1b                	jmp    2765 <rmm_evict+0x1a5>
    274a:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2751 <rmm_evict+0x191>
	if (dma_is_direct(ops))
    2751:	48 85 c0             	test   %rax,%rax
    2754:	75 da                	jne    2730 <rmm_evict+0x170>
		dma_direct_sync_single_for_device(dev, addr, size, dir);
    2756:	31 c9                	xor    %ecx,%ecx
    2758:	ba 10 10 00 00       	mov    $0x1010,%edx
    275d:	4c 89 de             	mov    %r11,%rsi
    2760:	e8 00 00 00 00       	callq  2765 <rmm_evict+0x1a5>
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    2765:	49 8b bc 24 40 01 00 	mov    0x140(%r12),%rdi
    276c:	00 
    276d:	49 8d 77 28          	lea    0x28(%r15),%rsi
    2771:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
    2775:	48 8b 07             	mov    (%rdi),%rax
    2778:	48 8b 40 08          	mov    0x8(%rax),%rax
    277c:	e8 00 00 00 00       	callq  2781 <rmm_evict+0x1c1>
	if (ret || bad_wr) {
    2781:	85 c0                	test   %eax,%eax
    2783:	41 89 c5             	mov    %eax,%r13d
    2786:	75 65                	jne    27ed <rmm_evict+0x22d>
    2788:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    278d:	75 5e                	jne    27ed <rmm_evict+0x22d>
	DEBUG_LOG(PFX "wait %p\n", rw);
    278f:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 2795 <rmm_evict+0x1d5>
    2795:	85 c0                	test   %eax,%eax
    2797:	0f 85 b2 00 00 00    	jne    284f <rmm_evict+0x28f>
	} while(!(done_evict = rw->done));
    279d:	41 80 7f 60 00       	cmpb   $0x0,0x60(%r15)
    27a2:	74 f9                	je     279d <rmm_evict+0x1dd>
	DEBUG_LOG(PFX "reclaim done %s\n", my_data);
    27a4:	44 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13d        # 27ab <rmm_evict+0x1eb>
    27ab:	45 85 ed             	test   %r13d,%r13d
    27ae:	0f 85 80 00 00 00    	jne    2834 <rmm_evict+0x274>
    27b4:	48 89 df             	mov    %rbx,%rdi
    27b7:	e8 00 00 00 00       	callq  27bc <rmm_evict+0x1fc>
		asm volatile(LOCK_PREFIX __ASM_SIZE(btr) " %1,%0"
    27bc:	f0 4d 0f b3 b4 24 d8 	lock btr %r14,0xd8(%r12)
    27c3:	00 00 00 
    27c6:	48 89 df             	mov    %rbx,%rdi
    27c9:	ff 14 25 00 00 00 00 	callq  *0x0
	__put_rdma_work(rh, rw);
    27d0:	4c 89 fe             	mov    %r15,%rsi
    27d3:	4c 89 e7             	mov    %r12,%rdi
    27d6:	e8 65 d9 ff ff       	callq  140 <__put_rdma_work>
}
    27db:	48 83 c4 28          	add    $0x28,%rsp
    27df:	44 89 e8             	mov    %r13d,%eax
    27e2:	5b                   	pop    %rbx
    27e3:	41 5c                	pop    %r12
    27e5:	41 5d                	pop    %r13
    27e7:	41 5e                	pop    %r14
    27e9:	41 5f                	pop    %r15
    27eb:	5d                   	pop    %rbp
    27ec:	c3                   	retq   
		printk(KERN_ERR PFX "Cannot post send wr, %d %p\n", ret, bad_wr);
    27ed:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    27f1:	44 89 ee             	mov    %r13d,%esi
    27f4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    27fb:	e8 00 00 00 00       	callq  2800 <rmm_evict+0x240>
    2800:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    2805:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    280a:	44 0f 45 e8          	cmovne %eax,%r13d
    280e:	eb a4                	jmp    27b4 <rmm_evict+0x1f4>
	DEBUG_LOG(PFX "i: %d, id: %d, imm_data: %X\n", i, rw->id, rw->wr.wr.ex.imm_data);
    2810:	44 89 ce             	mov    %r9d,%esi
    2813:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    281a:	4c 89 5d b8          	mov    %r11,-0x48(%rbp)
    281e:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
    2822:	e8 00 00 00 00       	callq  2827 <rmm_evict+0x267>
    2827:	4c 8b 5d b8          	mov    -0x48(%rbp),%r11
    282b:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
    282f:	e9 a2 fe ff ff       	jmpq   26d6 <rmm_evict+0x116>
	DEBUG_LOG(PFX "reclaim done %s\n", my_data);
    2834:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 283b <rmm_evict+0x27b>
    283b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	ret = ib_post_send(rh->qp, &rw->wr.wr, &bad_wr);
    2842:	45 31 ed             	xor    %r13d,%r13d
	DEBUG_LOG(PFX "reclaim done %s\n", my_data);
    2845:	e8 00 00 00 00       	callq  284a <rmm_evict+0x28a>
    284a:	e9 65 ff ff ff       	jmpq   27b4 <rmm_evict+0x1f4>
	DEBUG_LOG(PFX "wait %p\n", rw);
    284f:	4c 89 fe             	mov    %r15,%rsi
    2852:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2859:	e8 00 00 00 00       	callq  285e <rmm_evict+0x29e>
    285e:	e9 3a ff ff ff       	jmpq   279d <rmm_evict+0x1dd>
    2863:	0f 1f 00             	nopl   (%rax)
    2866:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    286d:	00 00 00 

0000000000002870 <rmm_write_proc>:
	printk(KERN_INFO PFX "average elapsed time %lu (ns)\n", total / 500);
}

static ssize_t rmm_write_proc(struct file *file, const char __user *buffer,
		size_t count, loff_t *ppos)
{
    2870:	e8 00 00 00 00       	callq  2875 <rmm_write_proc+0x5>
    2875:	55                   	push   %rbp
				kmalloc_caches[kmalloc_type(flags)][index],
				flags, size);
#endif
	}
	return __kmalloc(size, flags);
    2876:	48 89 d7             	mov    %rdx,%rdi
    2879:	48 89 e5             	mov    %rsp,%rbp
    287c:	41 57                	push   %r15
    287e:	41 56                	push   %r14
    2880:	41 55                	push   %r13
    2882:	41 54                	push   %r12
    2884:	49 89 f5             	mov    %rsi,%r13
    2887:	53                   	push   %rbx
    2888:	be c0 0c 00 00       	mov    $0xcc0,%esi
    288d:	49 89 d4             	mov    %rdx,%r12
    2890:	48 83 ec 18          	sub    $0x18,%rsp
    2894:	e8 00 00 00 00       	callq  2899 <rmm_write_proc+0x29>
	char *cmd;

	cmd = kmalloc(count, GFP_KERNEL);
	if (cmd == NULL) {
    2899:	48 85 c0             	test   %rax,%rax
    289c:	0f 84 33 03 00 00    	je     2bd5 <rmm_write_proc+0x365>
    28a2:	48 89 c3             	mov    %rax,%rbx

static __always_inline void check_object_size(const void *ptr, unsigned long n,
					      bool to_user)
{
	if (!__builtin_constant_p(n))
		__check_object_size(ptr, n, to_user);
    28a5:	31 d2                	xor    %edx,%edx
    28a7:	48 89 c7             	mov    %rax,%rdi
    28aa:	4c 89 e6             	mov    %r12,%rsi
    28ad:	e8 00 00 00 00       	callq  28b2 <rmm_write_proc+0x42>

static __always_inline unsigned long __must_check
copy_from_user(void *to, const void __user *from, unsigned long n)
{
	if (likely(check_copy_size(to, n, false)))
		n = _copy_from_user(to, from, n);
    28b2:	4c 89 ee             	mov    %r13,%rsi
    28b5:	4c 89 e2             	mov    %r12,%rdx
    28b8:	48 89 df             	mov    %rbx,%rdi
    28bb:	e8 00 00 00 00       	callq  28c0 <rmm_write_proc+0x50>
		printk(KERN_ERR PFX "kmalloc failure\n");
		return -ENOMEM;
	}
	if (copy_from_user(cmd, buffer, count)) {
    28c0:	48 85 c0             	test   %rax,%rax
    28c3:	49 89 c5             	mov    %rax,%r13
    28c6:	0f 85 d0 02 00 00    	jne    2b9c <rmm_write_proc+0x32c>
		kfree(cmd);
		return -EFAULT;
	}
	cmd[count-1] = 0;
	DEBUG_LOG(KERN_INFO PFX "proc write: %s\n", cmd);
    28cc:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 28d3 <rmm_write_proc+0x63>
	cmd[count-1] = 0;
    28d3:	42 c6 44 23 ff 00    	movb   $0x0,-0x1(%rbx,%r12,1)
	DEBUG_LOG(KERN_INFO PFX "proc write: %s\n", cmd);
    28d9:	45 85 c9             	test   %r9d,%r9d
    28dc:	0f 85 df 02 00 00    	jne    2bc1 <rmm_write_proc+0x351>

	if (strcmp("diss", cmd) == 0)
    28e2:	b9 05 00 00 00       	mov    $0x5,%ecx
    28e7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    28ee:	48 89 df             	mov    %rbx,%rdi
    28f1:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    28f3:	0f 97 c0             	seta   %al
    28f6:	1c 00                	sbb    $0x0,%al
    28f8:	84 c0                	test   %al,%al
    28fa:	0f 84 27 01 00 00    	je     2a27 <rmm_write_proc+0x1b7>
		disconnect();
	else if (strcmp("tf", cmd) == 0)
    2900:	b9 03 00 00 00       	mov    $0x3,%ecx
    2905:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    290c:	48 89 df             	mov    %rbx,%rdi
    290f:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    2911:	0f 97 c0             	seta   %al
    2914:	1c 00                	sbb    $0x0,%al
    2916:	84 c0                	test   %al,%al
    2918:	74 30                	je     294a <rmm_write_proc+0xda>
		test_fetch();
	else if (strcmp("te", cmd) == 0)
    291a:	b9 03 00 00 00       	mov    $0x3,%ecx
    291f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2926:	48 89 df             	mov    %rbx,%rdi
    2929:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    292b:	0f 97 c0             	seta   %al
    292e:	1c 00                	sbb    $0x0,%al
    2930:	84 c0                	test   %al,%al
    2932:	0f 84 c2 01 00 00    	je     2afa <rmm_write_proc+0x28a>
		test_evict();

	return count;
    2938:	4c 89 e0             	mov    %r12,%rax
}
    293b:	48 83 c4 18          	add    $0x18,%rsp
    293f:	5b                   	pop    %rbx
    2940:	41 5c                	pop    %r12
    2942:	41 5d                	pop    %r13
    2944:	41 5e                	pop    %r14
    2946:	41 5f                	pop    %r15
    2948:	5d                   	pop    %rbp
    2949:	c3                   	retq   
		return kmem_cache_alloc_trace(
    294a:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 2951 <rmm_write_proc+0xe1>
    2951:	ba e8 03 00 00       	mov    $0x3e8,%edx
    2956:	be c0 0c 00 00       	mov    $0xcc0,%esi
    295b:	e8 00 00 00 00       	callq  2960 <rmm_write_proc+0xf0>
	if (!arr)
    2960:	48 85 c0             	test   %rax,%rax
    2963:	74 d3                	je     2938 <rmm_write_proc+0xc8>
    2965:	4c 8d a8 e8 03 00 00 	lea    0x3e8(%rax),%r13
    296c:	49 89 c6             	mov    %rax,%r14
    296f:	48 89 c3             	mov    %rax,%rbx
		get_random_bytes(&index, sizeof(index));
    2972:	48 8d 7d c6          	lea    -0x3a(%rbp),%rdi
    2976:	be 02 00 00 00       	mov    $0x2,%esi
    297b:	48 83 c3 02          	add    $0x2,%rbx
    297f:	e8 00 00 00 00       	callq  2984 <rmm_write_proc+0x114>
		index %= 512;
    2984:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
    2988:	66 81 e2 ff 01       	and    $0x1ff,%dx
		arr[i] = index;
    298d:	66 89 53 fe          	mov    %dx,-0x2(%rbx)
	for (i = 0; i < 500; i++) {
    2991:	49 39 dd             	cmp    %rbx,%r13
		index %= 512;
    2994:	66 89 55 c6          	mov    %dx,-0x3a(%rbp)
	for (i = 0; i < 500; i++) {
    2998:	75 d8                	jne    2972 <rmm_write_proc+0x102>
	DEBUG_LOG(PFX "alloc\n");
    299a:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 29a0 <rmm_write_proc+0x130>
    29a0:	85 f6                	test   %esi,%esi
    29a2:	0f 85 45 02 00 00    	jne    2bed <rmm_write_proc+0x37d>
	rmm_alloc(0);
    29a8:	31 ff                	xor    %edi,%edi
    29aa:	e8 00 00 00 00       	callq  29af <rmm_write_proc+0x13f>
	if (server)
    29af:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 29b5 <rmm_write_proc+0x145>
    29b5:	85 c9                	test   %ecx,%ecx
    29b7:	0f 85 7b ff ff ff    	jne    2938 <rmm_write_proc+0xc8>
	DEBUG_LOG(PFX "fetch start\n");
    29bd:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 29c4 <rmm_write_proc+0x154>
    29c4:	74 0c                	je     29d2 <rmm_write_proc+0x162>
    29c6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    29cd:	e8 00 00 00 00       	callq  29d2 <rmm_write_proc+0x162>

static inline void getnstimeofday(struct timespec *ts)
{
	struct timespec64 ts64;

	ktime_get_real_ts64(&ts64);
    29d2:	4c 8d 7d c8          	lea    -0x38(%rbp),%r15
    29d6:	4c 89 ff             	mov    %r15,%rdi
    29d9:	e8 00 00 00 00       	callq  29de <rmm_write_proc+0x16e>
		rmm_fetch(0, my_data + (arr[i] * PAGE_SIZE), remote_data + (arr[i] * PAGE_SIZE), 0);
    29de:	41 0f b7 06          	movzwl (%r14),%eax
    29e2:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 29e9 <rmm_write_proc+0x179>
    29e9:	31 c9                	xor    %ecx,%ecx
    29eb:	31 ff                	xor    %edi,%edi
    29ed:	49 83 c6 02          	add    $0x2,%r14
    29f1:	48 c1 e0 0c          	shl    $0xc,%rax
    29f5:	48 01 c2             	add    %rax,%rdx
    29f8:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # 29ff <rmm_write_proc+0x18f>
    29ff:	48 89 c6             	mov    %rax,%rsi
    2a02:	e8 00 00 00 00       	callq  2a07 <rmm_write_proc+0x197>
	for (i = 0; i < 500; i++) {
    2a07:	4c 39 f3             	cmp    %r14,%rbx
    2a0a:	75 d2                	jne    29de <rmm_write_proc+0x16e>
    2a0c:	4c 89 ff             	mov    %r15,%rdi
    2a0f:	e8 00 00 00 00       	callq  2a14 <rmm_write_proc+0x1a4>
	printk(KERN_INFO PFX "average elapsed time %lu (ns)\n", total / 500);
    2a14:	31 f6                	xor    %esi,%esi
    2a16:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2a1d:	e8 00 00 00 00       	callq  2a22 <rmm_write_proc+0x1b2>
    2a22:	e9 11 ff ff ff       	jmpq   2938 <rmm_write_proc+0xc8>
	if (polling_k)
    2a27:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 2a2e <rmm_write_proc+0x1be>
    2a2e:	48 85 ff             	test   %rdi,%rdi
    2a31:	74 05                	je     2a38 <rmm_write_proc+0x1c8>
		kthread_stop(polling_k);
    2a33:	e8 00 00 00 00       	callq  2a38 <rmm_write_proc+0x1c8>
	if (server && accept_k) {
    2a38:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 2a3f <rmm_write_proc+0x1cf>
    2a3f:	45 85 c0             	test   %r8d,%r8d
    2a42:	0f 84 a2 00 00 00    	je     2aea <rmm_write_proc+0x27a>
    2a48:	31 db                	xor    %ebx,%ebx
    2a4a:	48 83 3d 00 00 00 00 	cmpq   $0x0,0x0(%rip)        # 2a52 <rmm_write_proc+0x1e2>
    2a51:	00 
    2a52:	49 c7 c5 00 00 00 00 	mov    $0x0,%r13
    2a59:	49 c7 c6 00 00 00 00 	mov    $0x0,%r14
    2a60:	0f 84 d2 fe ff ff    	je     2938 <rmm_write_proc+0xc8>
			complete(&rdma_handles[i]->cm_done);
    2a66:	49 8b 44 1d 00       	mov    0x0(%r13,%rbx,1),%rax
    2a6b:	48 8d 78 08          	lea    0x8(%rax),%rdi
    2a6f:	e8 00 00 00 00       	callq  2a74 <rmm_write_proc+0x204>
			complete(&rdma_handles_evic[i]->cm_done);
    2a74:	49 8b 04 1e          	mov    (%r14,%rbx,1),%rax
    2a78:	48 83 c3 08          	add    $0x8,%rbx
    2a7c:	48 8d 78 08          	lea    0x8(%rax),%rdi
    2a80:	e8 00 00 00 00       	callq  2a85 <rmm_write_proc+0x215>
		for (i = 0; i < MAX_NUM_NODES; i++) {
    2a85:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
    2a8c:	75 d8                	jne    2a66 <rmm_write_proc+0x1f6>
		kthread_stop(accept_k);
    2a8e:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 2a95 <rmm_write_proc+0x225>
    2a95:	e8 00 00 00 00       	callq  2a9a <rmm_write_proc+0x22a>
	if (!server)  {
    2a9a:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 2aa0 <rmm_write_proc+0x230>
    2aa0:	85 ff                	test   %edi,%edi
    2aa2:	0f 85 90 fe ff ff    	jne    2938 <rmm_write_proc+0xc8>
	if (server && accept_k) {
    2aa8:	31 db                	xor    %ebx,%ebx
			if (rdma_handles[i])
    2aaa:	49 8b 44 1d 00       	mov    0x0(%r13,%rbx,1),%rax
    2aaf:	48 85 c0             	test   %rax,%rax
    2ab2:	74 0c                	je     2ac0 <rmm_write_proc+0x250>
				rdma_disconnect(rdma_handles[i]->cm_id);
    2ab4:	48 8b b8 28 01 00 00 	mov    0x128(%rax),%rdi
    2abb:	e8 00 00 00 00       	callq  2ac0 <rmm_write_proc+0x250>
			if (rdma_handles_evic[i])
    2ac0:	49 83 3c 1e 00       	cmpq   $0x0,(%r14,%rbx,1)
    2ac5:	74 11                	je     2ad8 <rmm_write_proc+0x268>
				rdma_disconnect(rdma_handles[i]->cm_id);
    2ac7:	49 8b 44 1d 00       	mov    0x0(%r13,%rbx,1),%rax
    2acc:	48 8b b8 28 01 00 00 	mov    0x128(%rax),%rdi
    2ad3:	e8 00 00 00 00       	callq  2ad8 <rmm_write_proc+0x268>
    2ad8:	48 83 c3 08          	add    $0x8,%rbx
		for (i = 0; i < MAX_NUM_NODES; i++) {
    2adc:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
    2ae3:	75 c5                	jne    2aaa <rmm_write_proc+0x23a>
    2ae5:	e9 4e fe ff ff       	jmpq   2938 <rmm_write_proc+0xc8>
    2aea:	49 c7 c5 00 00 00 00 	mov    $0x0,%r13
    2af1:	49 c7 c6 00 00 00 00 	mov    $0x0,%r14
    2af8:	eb ae                	jmp    2aa8 <rmm_write_proc+0x238>
	DEBUG_LOG(PFX "alloc\n");
    2afa:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 2b00 <rmm_write_proc+0x290>
    2b00:	85 d2                	test   %edx,%edx
    2b02:	0f 85 a8 00 00 00    	jne    2bb0 <rmm_write_proc+0x340>
	rmm_alloc(0);
    2b08:	31 ff                	xor    %edi,%edi
    2b0a:	e8 00 00 00 00       	callq  2b0f <rmm_write_proc+0x29f>
	if (server)
    2b0f:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 2b15 <rmm_write_proc+0x2a5>
    2b15:	85 c0                	test   %eax,%eax
    2b17:	0f 85 1b fe ff ff    	jne    2938 <rmm_write_proc+0xc8>
	DEBUG_LOG(PFX "fetch start\n");
    2b1d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 2b24 <rmm_write_proc+0x2b4>
    2b24:	74 0c                	je     2b32 <rmm_write_proc+0x2c2>
    2b26:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2b2d:	e8 00 00 00 00       	callq  2b32 <rmm_write_proc+0x2c2>
	if (!arr)
    2b32:	31 db                	xor    %ebx,%ebx
		sprintf(my_data + (i * PAGE_SIZE), "This is %d", i);
    2b34:	49 c7 c6 00 00 00 00 	mov    $0x0,%r14
    2b3b:	48 89 df             	mov    %rbx,%rdi
    2b3e:	89 da                	mov    %ebx,%edx
    2b40:	4c 89 f6             	mov    %r14,%rsi
    2b43:	48 c1 e7 0c          	shl    $0xc,%rdi
    2b47:	48 03 3d 00 00 00 00 	add    0x0(%rip),%rdi        # 2b4e <rmm_write_proc+0x2de>
    2b4e:	48 83 c3 01          	add    $0x1,%rbx
    2b52:	e8 00 00 00 00       	callq  2b57 <rmm_write_proc+0x2e7>
	for (i = 0; i < 500; i++) {
    2b57:	48 81 fb f4 01 00 00 	cmp    $0x1f4,%rbx
    2b5e:	75 db                	jne    2b3b <rmm_write_proc+0x2cb>
    2b60:	4c 8d 7d c8          	lea    -0x38(%rbp),%r15
    2b64:	4c 89 ff             	mov    %r15,%rdi
    2b67:	e8 00 00 00 00       	callq  2b6c <rmm_write_proc+0x2fc>
		rmm_evict(0, remote_data + (i * PAGE_SIZE), my_data + (i * PAGE_SIZE));
    2b6c:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 2b73 <rmm_write_proc+0x303>
    2b73:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2b7a <rmm_write_proc+0x30a>
    2b7a:	31 ff                	xor    %edi,%edi
    2b7c:	4c 01 ea             	add    %r13,%rdx
    2b7f:	4c 01 ee             	add    %r13,%rsi
    2b82:	49 81 c5 00 10 00 00 	add    $0x1000,%r13
    2b89:	e8 00 00 00 00       	callq  2b8e <rmm_write_proc+0x31e>
	for (i = 0; i < 500; i++) {
    2b8e:	49 81 fd 00 40 1f 00 	cmp    $0x1f4000,%r13
    2b95:	75 d5                	jne    2b6c <rmm_write_proc+0x2fc>
    2b97:	e9 70 fe ff ff       	jmpq   2a0c <rmm_write_proc+0x19c>
		kfree(cmd);
    2b9c:	48 89 df             	mov    %rbx,%rdi
    2b9f:	e8 00 00 00 00       	callq  2ba4 <rmm_write_proc+0x334>
		return -EFAULT;
    2ba4:	48 c7 c0 f2 ff ff ff 	mov    $0xfffffffffffffff2,%rax
    2bab:	e9 8b fd ff ff       	jmpq   293b <rmm_write_proc+0xcb>
	DEBUG_LOG(PFX "alloc\n");
    2bb0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2bb7:	e8 00 00 00 00       	callq  2bbc <rmm_write_proc+0x34c>
    2bbc:	e9 47 ff ff ff       	jmpq   2b08 <rmm_write_proc+0x298>
	DEBUG_LOG(KERN_INFO PFX "proc write: %s\n", cmd);
    2bc1:	48 89 de             	mov    %rbx,%rsi
    2bc4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2bcb:	e8 00 00 00 00       	callq  2bd0 <rmm_write_proc+0x360>
    2bd0:	e9 0d fd ff ff       	jmpq   28e2 <rmm_write_proc+0x72>
		printk(KERN_ERR PFX "kmalloc failure\n");
    2bd5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2bdc:	e8 00 00 00 00       	callq  2be1 <rmm_write_proc+0x371>
		return -ENOMEM;
    2be1:	48 c7 c0 f4 ff ff ff 	mov    $0xfffffffffffffff4,%rax
    2be8:	e9 4e fd ff ff       	jmpq   293b <rmm_write_proc+0xcb>
	DEBUG_LOG(PFX "alloc\n");
    2bed:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2bf4:	e8 00 00 00 00       	callq  2bf9 <rmm_write_proc+0x389>
    2bf9:	e9 aa fd ff ff       	jmpq   29a8 <rmm_write_proc+0x138>

Disassembly of section .text.unlikely:

0000000000000000 <__connect_to_server>:
{
   0:	e8 00 00 00 00       	callq  5 <__connect_to_server+0x5>
   5:	55                   	push   %rbp
   6:	48 89 e5             	mov    %rsp,%rbp
   9:	41 57                	push   %r15
   b:	41 56                	push   %r14
   d:	41 55                	push   %r13
   f:	41 54                	push   %r12
  11:	41 89 f7             	mov    %esi,%r15d
  14:	53                   	push   %rbx
  15:	4c 63 e7             	movslq %edi,%r12
  18:	48 83 ec 38          	sub    $0x38,%rsp
  1c:	89 7d a4             	mov    %edi,-0x5c(%rbp)
  1f:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
  26:	00 00 
  28:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  2c:	31 c0                	xor    %eax,%eax
	if (connect_type == CONNECTION_FETCH)
  2e:	85 f6                	test   %esi,%esi
  30:	75 0a                	jne    3c <__connect_to_server+0x3c>
		rh = rdma_handles[nid];
  32:	4a 8b 1c e5 00 00 00 	mov    0x0(,%r12,8),%rbx
  39:	00 
  3a:	eb 08                	jmp    44 <__connect_to_server+0x44>
		rh = rdma_handles_evic[nid];
  3c:	4a 8b 1c e5 00 00 00 	mov    0x0(,%r12,8),%rbx
  43:	00 
	DEBUG_LOG(PFX "%s\n", step);
  44:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 4b <__connect_to_server+0x4b>
  4b:	74 13                	je     60 <__connect_to_server+0x60>
  4d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
  54:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  5b:	e8 00 00 00 00       	callq  60 <__connect_to_server+0x60>
	rh->cm_id = rdma_create_id(&init_net,
  60:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
  67:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  6d:	b9 3f 01 00 00       	mov    $0x13f,%ecx
  72:	48 89 da             	mov    %rbx,%rdx
  75:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
  7c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  83:	e8 00 00 00 00       	callq  88 <__connect_to_server+0x88>
	if (IS_ERR(rh->cm_id)) 
  88:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
	rh->cm_id = rdma_create_id(&init_net,
  8e:	48 89 83 28 01 00 00 	mov    %rax,0x128(%rbx)
	if (IS_ERR(rh->cm_id)) 
  95:	0f 87 57 02 00 00    	ja     2f2 <__connect_to_server+0x2f2>
	DEBUG_LOG(PFX "%s\n", step);
  9b:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # a2 <__connect_to_server+0xa2>
  a2:	74 13                	je     b7 <__connect_to_server+0xb7>
  a4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
  ab:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  b2:	e8 00 00 00 00       	callq  b7 <__connect_to_server+0xb7>
		struct sockaddr_in addr = {
  b7:	42 8b 04 a5 00 00 00 	mov    0x0(,%r12,4),%eax
  be:	00 
		ret = rdma_resolve_addr(rh->cm_id, NULL,
  bf:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
  c6:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  ca:	31 f6                	xor    %esi,%esi
  cc:	b9 88 13 00 00       	mov    $0x1388,%ecx
		struct sockaddr_in addr = {
  d1:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  d8:	00 
  d9:	c7 45 c0 02 00 2c bd 	movl   $0xbd2c0002,-0x40(%rbp)
  e0:	89 45 c4             	mov    %eax,-0x3c(%rbp)
		ret = rdma_resolve_addr(rh->cm_id, NULL,
  e3:	e8 00 00 00 00       	callq  e8 <__connect_to_server+0xe8>
		if (ret) 
  e8:	85 c0                	test   %eax,%eax
		ret = rdma_resolve_addr(rh->cm_id, NULL,
  ea:	41 89 c6             	mov    %eax,%r14d
		if (ret) 
  ed:	75 37                	jne    126 <__connect_to_server+0x126>
		ret = wait_for_completion_interruptible(&rh->cm_done);
  ef:	4c 8d 6b 08          	lea    0x8(%rbx),%r13
  f3:	4c 89 ef             	mov    %r13,%rdi
  f6:	e8 00 00 00 00       	callq  fb <__connect_to_server+0xfb>
		if (ret || rh->state != RDMA_ADDR_RESOLVED) 
  fb:	85 c0                	test   %eax,%eax
		ret = wait_for_completion_interruptible(&rh->cm_done);
  fd:	41 89 c6             	mov    %eax,%r14d
		if (ret || rh->state != RDMA_ADDR_RESOLVED) 
 100:	75 24                	jne    126 <__connect_to_server+0x126>
 102:	83 7b 04 01          	cmpl   $0x1,0x4(%rbx)
 106:	75 1e                	jne    126 <__connect_to_server+0x126>
	DEBUG_LOG(PFX "%s\n", step);
 108:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 10f <__connect_to_server+0x10f>
 10f:	74 21                	je     132 <__connect_to_server+0x132>
 111:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 118:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 11f:	e8 00 00 00 00       	callq  124 <__connect_to_server+0x124>
 124:	eb 0c                	jmp    132 <__connect_to_server+0x132>
	step = "resolve server address";
 126:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 12d:	e9 00 02 00 00       	jmpq   332 <__connect_to_server+0x332>
	ret = rdma_resolve_route(rh->cm_id, RDMA_ADDR_RESOLVE_TIMEOUT_MS);
 132:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
 139:	be 88 13 00 00       	mov    $0x1388,%esi
 13e:	e8 00 00 00 00       	callq  143 <__connect_to_server+0x143>
	if (ret) 
 143:	85 c0                	test   %eax,%eax
	ret = rdma_resolve_route(rh->cm_id, RDMA_ADDR_RESOLVE_TIMEOUT_MS);
 145:	41 89 c6             	mov    %eax,%r14d
	if (ret) 
 148:	0f 85 b0 01 00 00    	jne    2fe <__connect_to_server+0x2fe>
	ret = wait_for_completion_interruptible(&rh->cm_done);
 14e:	4c 89 ef             	mov    %r13,%rdi
 151:	e8 00 00 00 00       	callq  156 <__connect_to_server+0x156>
	if (ret || rh->state != RDMA_ROUTE_RESOLVED) 
 156:	85 c0                	test   %eax,%eax
	ret = wait_for_completion_interruptible(&rh->cm_done);
 158:	41 89 c6             	mov    %eax,%r14d
	if (ret || rh->state != RDMA_ROUTE_RESOLVED) 
 15b:	0f 85 9d 01 00 00    	jne    2fe <__connect_to_server+0x2fe>
 161:	83 7b 04 02          	cmpl   $0x2,0x4(%rbx)
 165:	0f 85 93 01 00 00    	jne    2fe <__connect_to_server+0x2fe>
	rh->device = rh->cm_id->device;
 16b:	48 8b 83 28 01 00 00 	mov    0x128(%rbx),%rax
	DEBUG_LOG(PFX "%s\n", step);
 172:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 179 <__connect_to_server+0x179>
	rh->device = rh->cm_id->device;
 179:	48 8b 00             	mov    (%rax),%rax
 17c:	48 89 83 30 01 00 00 	mov    %rax,0x130(%rbx)
	DEBUG_LOG(PFX "%s\n", step);
 183:	74 13                	je     198 <__connect_to_server+0x198>
 185:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 18c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 193:	e8 00 00 00 00       	callq  198 <__connect_to_server+0x198>
	ret = __setup_pd_cq_qp(rh);
 198:	48 89 df             	mov    %rbx,%rdi
 19b:	e8 00 00 00 00       	callq  1a0 <__connect_to_server+0x1a0>
	if (ret) 
 1a0:	85 c0                	test   %eax,%eax
	ret = __setup_pd_cq_qp(rh);
 1a2:	41 89 c6             	mov    %eax,%r14d
	if (ret) 
 1a5:	0f 85 5c 01 00 00    	jne    307 <__connect_to_server+0x307>
	ret = __setup_recv_works(rh);
 1ab:	48 89 df             	mov    %rbx,%rdi
 1ae:	e8 00 00 00 00       	callq  1b3 <__connect_to_server+0x1b3>
	if (ret) 
 1b3:	85 c0                	test   %eax,%eax
	ret = __setup_recv_works(rh);
 1b5:	41 89 c6             	mov    %eax,%r14d
	if (ret) 
 1b8:	0f 85 52 01 00 00    	jne    310 <__connect_to_server+0x310>
	ret = __refill_rdma_work(rh, NR_RPC_SLOTS);
 1be:	48 89 df             	mov    %rbx,%rdi
 1c1:	e8 00 00 00 00       	callq  1c6 <__connect_to_server+0x1c6>
	if (ret == 0)
 1c6:	85 c0                	test   %eax,%eax
	ret = __refill_rdma_work(rh, NR_RPC_SLOTS);
 1c8:	41 89 c6             	mov    %eax,%r14d
	if (ret == 0)
 1cb:	0f 84 48 01 00 00    	je     319 <__connect_to_server+0x319>
	DEBUG_LOG(PFX "%s\n", step);
 1d1:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1d8 <__connect_to_server+0x1d8>
 1d8:	74 13                	je     1ed <__connect_to_server+0x1ed>
 1da:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 1e1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1e8:	e8 00 00 00 00       	callq  1ed <__connect_to_server+0x1ed>
		ret = rdma_connect(rh->cm_id, &conn_param);
 1ed:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
 1f4:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
		struct rdma_conn_param conn_param = {
 1f8:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
 1ff:	00 
 200:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
 207:	00 
 208:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
 20f:	00 
 210:	c6 45 b0 04          	movb   $0x4,-0x50(%rbp)
		rh->state = RDMA_CONNECTING;
 214:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%rbx)
	c_type = connect_type;
 21b:	44 89 3d 00 00 00 00 	mov    %r15d,0x0(%rip)        # 222 <__connect_to_server+0x222>
		ret = rdma_connect(rh->cm_id, &conn_param);
 222:	e8 00 00 00 00       	callq  227 <__connect_to_server+0x227>
		if (ret) 
 227:	85 c0                	test   %eax,%eax
		ret = rdma_connect(rh->cm_id, &conn_param);
 229:	41 89 c6             	mov    %eax,%r14d
		if (ret) 
 22c:	75 39                	jne    267 <__connect_to_server+0x267>
		ret = wait_for_completion_interruptible(&rh->cm_done);
 22e:	4c 89 ef             	mov    %r13,%rdi
 231:	e8 00 00 00 00       	callq  236 <__connect_to_server+0x236>
		if (ret) 
 236:	85 c0                	test   %eax,%eax
		ret = wait_for_completion_interruptible(&rh->cm_done);
 238:	41 89 c6             	mov    %eax,%r14d
		if (ret) 
 23b:	75 2a                	jne    267 <__connect_to_server+0x267>
		if (rh->state != RDMA_CONNECTED) {
 23d:	83 7b 04 04          	cmpl   $0x4,0x4(%rbx)
 241:	75 1e                	jne    261 <__connect_to_server+0x261>
	DEBUG_LOG(PFX "%s\n", step);
 243:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 24a <__connect_to_server+0x24a>
 24a:	74 27                	je     273 <__connect_to_server+0x273>
 24c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 253:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 25a:	e8 00 00 00 00       	callq  25f <__connect_to_server+0x25f>
 25f:	eb 12                	jmp    273 <__connect_to_server+0x273>
			ret = -ETIMEDOUT;
 261:	41 be 92 ff ff ff    	mov    $0xffffff92,%r14d
	step = "connect";
 267:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 26e:	e9 bf 00 00 00       	jmpq   332 <__connect_to_server+0x332>
	ret = __setup_dma_buffer(rh);
 273:	48 89 df             	mov    %rbx,%rdi
 276:	e8 00 00 00 00       	callq  27b <__connect_to_server+0x27b>
	if (ret)
 27b:	85 c0                	test   %eax,%eax
	ret = __setup_dma_buffer(rh);
 27d:	41 89 c6             	mov    %eax,%r14d
	if (ret)
 280:	0f 85 9c 00 00 00    	jne    322 <__connect_to_server+0x322>
	DEBUG_LOG(PFX "%s %llx %llx\n", step, rh->rpc_dma_addr, rh->sink_dma_addr);
 286:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 28d <__connect_to_server+0x28d>
 28d:	74 1b                	je     2aa <__connect_to_server+0x2aa>
 28f:	48 8b 4b 78          	mov    0x78(%rbx),%rcx
 293:	48 8b 53 70          	mov    0x70(%rbx),%rdx
 297:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 29e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2a5:	e8 00 00 00 00       	callq  2aa <__connect_to_server+0x2aa>
	ret = __send_dma_addr(rh, rh->rpc_dma_addr, RPC_BUFFER_SIZE);
 2aa:	48 8b 73 70          	mov    0x70(%rbx),%rsi
 2ae:	ba 00 10 00 00       	mov    $0x1000,%edx
 2b3:	48 89 df             	mov    %rbx,%rdi
 2b6:	e8 00 00 00 00       	callq  2bb <__connect_to_server+0x2bb>
	if (ret)
 2bb:	85 c0                	test   %eax,%eax
	ret = __send_dma_addr(rh, rh->rpc_dma_addr, RPC_BUFFER_SIZE);
 2bd:	41 89 c6             	mov    %eax,%r14d
	if (ret)
 2c0:	75 69                	jne    32b <__connect_to_server+0x32b>
	ret = __send_dma_addr(rh, rh->sink_dma_addr, SINK_BUFFER_SIZE);
 2c2:	48 8b 73 78          	mov    0x78(%rbx),%rsi
 2c6:	ba 00 00 10 00       	mov    $0x100000,%edx
 2cb:	48 89 df             	mov    %rbx,%rdi
 2ce:	e8 00 00 00 00       	callq  2d3 <__connect_to_server+0x2d3>
	if (ret)
 2d3:	85 c0                	test   %eax,%eax
	ret = __send_dma_addr(rh, rh->sink_dma_addr, SINK_BUFFER_SIZE);
 2d5:	41 89 c6             	mov    %eax,%r14d
	step = "send pool addr";
 2d8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	if (ret)
 2df:	75 51                	jne    332 <__connect_to_server+0x332>
	printk(PFX "Connected to %d\n", nid);
 2e1:	8b 75 a4             	mov    -0x5c(%rbp),%esi
 2e4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2eb:	e8 00 00 00 00       	callq  2f0 <__connect_to_server+0x2f0>
	return 0;
 2f0:	eb 57                	jmp    349 <__connect_to_server+0x349>
	step = "create rdma id";
 2f2:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	int ret = 0;
 2f9:	45 31 f6             	xor    %r14d,%r14d
 2fc:	eb 34                	jmp    332 <__connect_to_server+0x332>
	step = "resolve routing path";
 2fe:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 305:	eb 2b                	jmp    332 <__connect_to_server+0x332>
	step = "setup ib";
 307:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 30e:	eb 22                	jmp    332 <__connect_to_server+0x332>
	step = "post recv works";
 310:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 317:	eb 19                	jmp    332 <__connect_to_server+0x332>
	step = "setup work reqeusts";
 319:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 320:	eb 10                	jmp    332 <__connect_to_server+0x332>
	step = "setup dma buffers";
 322:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 329:	eb 07                	jmp    332 <__connect_to_server+0x332>
	step = "send pool addr";
 32b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	printk(KERN_ERR PFX "Unable to %s, %pI4, %d\n", step, ip_table + nid, ret);
 332:	4a 8d 14 a5 00 00 00 	lea    0x0(,%r12,4),%rdx
 339:	00 
 33a:	44 89 f1             	mov    %r14d,%ecx
 33d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 344:	e8 00 00 00 00       	callq  349 <__connect_to_server+0x349>
}
 349:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
 34d:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
 354:	00 00 
 356:	44 89 f0             	mov    %r14d,%eax
 359:	74 05                	je     360 <__connect_to_server+0x360>
 35b:	e8 00 00 00 00       	callq  360 <__connect_to_server+0x360>
 360:	48 83 c4 38          	add    $0x38,%rsp
 364:	5b                   	pop    %rbx
 365:	41 5c                	pop    %r12
 367:	41 5d                	pop    %r13
 369:	41 5e                	pop    %r14
 36b:	41 5f                	pop    %r15
 36d:	5d                   	pop    %rbp
 36e:	c3                   	retq   

Disassembly of section .init.text:

0000000000000000 <identify_myself>:
	}
	return -1;
}

bool __init identify_myself(uint32_t *my_ip)
{
   0:	e8 00 00 00 00       	callq  5 <identify_myself+0x5>
   5:	55                   	push   %rbp
   6:	48 89 e5             	mov    %rsp,%rbp
   9:	53                   	push   %rbx
   a:	48 89 fb             	mov    %rdi,%rbx
	int i;

	printk("rmm: Loading node configuration...");
   d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  14:	e8 00 00 00 00       	callq  19 <identify_myself+0x19>

	for (i = 0; i < MAX_NUM_NODES && i < ARRAY_SIZE(ip_addresses); i++) {
		ip_table[i] = in_aton(ip_addresses[i]);
  19:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 20 <identify_myself+0x20>
  20:	e8 00 00 00 00       	callq  25 <identify_myself+0x25>
  25:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 2b <identify_myself+0x2b>
	for_each_netdev(&init_net, d) {
  2b:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 32 <identify_myself+0x32>
  32:	48 83 e8 50          	sub    $0x50,%rax
  36:	48 3d 00 00 00 00    	cmp    $0x0,%rax
  3c:	74 37                	je     75 <identify_myself+0x75>
		for (ifaddr = d->ip_ptr->ifa_list; ifaddr; ifaddr = ifaddr->ifa_next) {
  3e:	48 8b 90 f8 02 00 00 	mov    0x2f8(%rax),%rdx
  45:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  49:	48 85 d2             	test   %rdx,%rdx
  4c:	74 1d                	je     6b <identify_myself+0x6b>
			uint32_t addr = ifaddr->ifa_local;
  4e:	8b 72 30             	mov    0x30(%rdx),%esi
  51:	31 c9                	xor    %ecx,%ecx
				if (addr == ip_table[i]) {
  53:	3b 34 8d 00 00 00 00 	cmp    0x0(,%rcx,4),%esi
  5a:	74 1c                	je     78 <identify_myself+0x78>
  5c:	48 ff c1             	inc    %rcx
			for (i = 0; i < MAX_NUM_NODES; i++) {
  5f:	48 83 f9 20          	cmp    $0x20,%rcx
  63:	75 ee                	jne    53 <identify_myself+0x53>
		for (ifaddr = d->ip_ptr->ifa_list; ifaddr; ifaddr = ifaddr->ifa_next) {
  65:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  69:	eb de                	jmp    49 <identify_myself+0x49>
	for_each_netdev(&init_net, d) {
  6b:	48 8b 40 50          	mov    0x50(%rax),%rax
  6f:	48 83 e8 50          	sub    $0x50,%rax
  73:	eb c1                	jmp    36 <identify_myself+0x36>
	return -1;
  75:	83 ce ff             	or     $0xffffffff,%esi
	}

	*my_ip = __get_host_ip();
  78:	89 33                	mov    %esi,(%rbx)
		return false;
	}
	*/

	return true;
}
  7a:	b0 01                	mov    $0x1,%al
  7c:	5b                   	pop    %rbx
  7d:	5d                   	pop    %rbp
  7e:	c3                   	retq   

000000000000007f <init_module>:
	.owner = THIS_MODULE,
	.write = rmm_write_proc,
};

int __init init_rmm_rdma(void)
{
  7f:	e8 00 00 00 00       	callq  84 <init_module+0x5>
  84:	55                   	push   %rbp
	int i;

	printk(PFX "init rmm rdma\n");
  85:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
{
  8c:	48 89 e5             	mov    %rsp,%rbp
  8f:	41 55                	push   %r13
  91:	41 54                	push   %r12
  93:	53                   	push   %rbx
  94:	48 83 ec 18          	sub    $0x18,%rsp
  98:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
  9f:	00 00 
  a1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  a5:	31 c0                	xor    %eax,%eax
	printk(PFX "init rmm rdma\n");
  a7:	e8 00 00 00 00       	callq  ac <init_module+0x2d>
	rmm_proc = proc_create("rmm", 0666, NULL, &rmm_ops);
  ac:	31 d2                	xor    %edx,%edx
  ae:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
  b5:	be b6 01 00 00       	mov    $0x1b6,%esi
  ba:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  c1:	e8 00 00 00 00       	callq  c6 <init_module+0x47>
	if (rmm_proc == NULL) {
  c6:	48 85 c0             	test   %rax,%rax
  c9:	75 16                	jne    e1 <init_module+0x62>
		printk(KERN_ERR PFX "cannot create /proc/rmm\n");
  cb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  d2:	e8 00 00 00 00       	callq  d7 <init_module+0x58>
		return -ENOMEM;
  d7:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  dc:	e9 7b 03 00 00       	jmpq   45c <init_module+0x3dd>
	}

	if (!identify_myself(&my_ip)) 
  e1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  e8:	e8 00 00 00 00       	callq  ed <init_module+0x6e>
  ed:	84 c0                	test   %al,%al
		return -EINVAL;
  ef:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (!identify_myself(&my_ip)) 
  f4:	0f 84 62 03 00 00    	je     45c <init_module+0x3dd>
  fa:	45 31 e4             	xor    %r12d,%r12d
 * structure.
 */
static inline void __init_completion(struct completion *x)
{
	x->done = 0;
	init_waitqueue_head(&x->wait);
  fd:	49 c7 c5 00 00 00 00 	mov    $0x0,%r13
 104:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 10b <init_module+0x8c>
 10b:	ba 50 01 00 00       	mov    $0x150,%edx
 110:	be c0 0d 00 00       	mov    $0xdc0,%esi
 115:	e8 00 00 00 00       	callq  11a <init_module+0x9b>

	for (i = 0; i < MAX_NUM_NODES; i++) {
		struct rdma_handle *rh;
		rh = rdma_handles[i] = kzalloc(sizeof(struct rdma_handle), GFP_KERNEL);
		if (!rh) 
 11a:	48 85 c0             	test   %rax,%rax
 11d:	48 89 c3             	mov    %rax,%rbx
		rh = rdma_handles[i] = kzalloc(sizeof(struct rdma_handle), GFP_KERNEL);
 120:	4a 89 04 e5 00 00 00 	mov    %rax,0x0(,%r12,8)
 127:	00 
		if (!rh) 
 128:	0f 84 24 03 00 00    	je     452 <init_module+0x3d3>
 12e:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 135 <init_module+0xb6>
 135:	ba 18 00 00 00       	mov    $0x18,%edx
 13a:	be c0 0d 00 00       	mov    $0xdc0,%esi
 13f:	e8 00 00 00 00       	callq  144 <init_module+0xc5>
			goto out_free;
		if (!(rpc_pools[i] = kzalloc(sizeof(struct pool_info), GFP_KERNEL)))
 144:	48 85 c0             	test   %rax,%rax
 147:	4a 89 04 e5 00 00 00 	mov    %rax,0x0(,%r12,8)
 14e:	00 
 14f:	0f 84 fd 02 00 00    	je     452 <init_module+0x3d3>
 155:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 15c <init_module+0xdd>
 15c:	ba 18 00 00 00       	mov    $0x18,%edx
 161:	be c0 0d 00 00       	mov    $0xdc0,%esi
 166:	e8 00 00 00 00       	callq  16b <init_module+0xec>
			goto out_free;
		if (!(sink_pools[i] = kzalloc(sizeof(struct pool_info), GFP_KERNEL)))
 16b:	48 85 c0             	test   %rax,%rax
 16e:	4a 89 04 e5 00 00 00 	mov    %rax,0x0(,%r12,8)
 175:	00 
 176:	0f 84 d6 02 00 00    	je     452 <init_module+0x3d3>
 17c:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
			goto out_free;

		rh->nid = i;
 180:	44 89 23             	mov    %r12d,(%rbx)
		rh->state = RDMA_INIT;
 183:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%rbx)
		rh->connection_type = CONNECTION_FETCH;
 18a:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%rbx)

		spin_lock_init(&rh->rdma_work_head_lock);
 191:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%rbx)
 198:	00 00 00 
 19b:	4c 89 ea             	mov    %r13,%rdx
		spin_lock_init(&rh->rpc_slots_lock);
 19e:	c7 83 f8 00 00 00 00 	movl   $0x0,0xf8(%rbx)
 1a5:	00 00 00 
		spin_lock_init(&rh->sink_slots_lock);
 1a8:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%rbx)
 1af:	00 00 00 
 1b2:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	x->done = 0;
 1b9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%rbx)
 1c0:	49 ff c4             	inc    %r12
	init_waitqueue_head(&x->wait);
 1c3:	e8 00 00 00 00       	callq  1c8 <init_module+0x149>
	for (i = 0; i < MAX_NUM_NODES; i++) {
 1c8:	49 83 fc 20          	cmp    $0x20,%r12
 1cc:	0f 85 32 ff ff ff    	jne    104 <init_module+0x85>
 1d2:	45 31 e4             	xor    %r12d,%r12d
 1d5:	49 c7 c5 00 00 00 00 	mov    $0x0,%r13
 1dc:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1e3 <init_module+0x164>
 1e3:	ba 50 01 00 00       	mov    $0x150,%edx
 1e8:	be c0 0d 00 00       	mov    $0xdc0,%esi
 1ed:	e8 00 00 00 00       	callq  1f2 <init_module+0x173>
		init_completion(&rh->cm_done);
	}
	for (i = 0; i < MAX_NUM_NODES; i++) {
		struct rdma_handle *rh;
		rh = rdma_handles_evic[i] = kzalloc(sizeof(struct rdma_handle), GFP_KERNEL);
		if (!rh) 
 1f2:	48 85 c0             	test   %rax,%rax
 1f5:	48 89 c3             	mov    %rax,%rbx
		rh = rdma_handles_evic[i] = kzalloc(sizeof(struct rdma_handle), GFP_KERNEL);
 1f8:	4a 89 04 e5 00 00 00 	mov    %rax,0x0(,%r12,8)
 1ff:	00 
		if (!rh) 
 200:	0f 84 4c 02 00 00    	je     452 <init_module+0x3d3>
 206:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 20d <init_module+0x18e>
 20d:	ba 18 00 00 00       	mov    $0x18,%edx
 212:	be c0 0d 00 00       	mov    $0xdc0,%esi
 217:	e8 00 00 00 00       	callq  21c <init_module+0x19d>
			goto out_free;
		if (!(rpc_pools_evic[i] = kzalloc(sizeof(struct pool_info), GFP_KERNEL)))
 21c:	48 85 c0             	test   %rax,%rax
 21f:	4a 89 04 e5 00 00 00 	mov    %rax,0x0(,%r12,8)
 226:	00 
 227:	0f 84 25 02 00 00    	je     452 <init_module+0x3d3>
 22d:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 234 <init_module+0x1b5>
 234:	ba 18 00 00 00       	mov    $0x18,%edx
 239:	be c0 0d 00 00       	mov    $0xdc0,%esi
 23e:	e8 00 00 00 00       	callq  243 <init_module+0x1c4>
			goto out_free;
		if (!(sink_pools_evic[i] = kzalloc(sizeof(struct pool_info), GFP_KERNEL)))
 243:	48 85 c0             	test   %rax,%rax
 246:	4a 89 04 e5 00 00 00 	mov    %rax,0x0(,%r12,8)
 24d:	00 
 24e:	0f 84 fe 01 00 00    	je     452 <init_module+0x3d3>
 254:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
			goto out_free;

		rh->nid = i;
 258:	44 89 23             	mov    %r12d,(%rbx)
		rh->state = RDMA_INIT;
 25b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%rbx)
		rh->connection_type = CONNECTION_EVICT;
 262:	c7 43 30 01 00 00 00 	movl   $0x1,0x30(%rbx)

		spin_lock_init(&rh->rdma_work_head_lock);
 269:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%rbx)
 270:	00 00 00 
 273:	4c 89 ea             	mov    %r13,%rdx
		spin_lock_init(&rh->rpc_slots_lock);
 276:	c7 83 f8 00 00 00 00 	movl   $0x0,0xf8(%rbx)
 27d:	00 00 00 
		spin_lock_init(&rh->sink_slots_lock);
 280:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%rbx)
 287:	00 00 00 
 28a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	x->done = 0;
 291:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%rbx)
 298:	49 ff c4             	inc    %r12
	init_waitqueue_head(&x->wait);
 29b:	e8 00 00 00 00       	callq  2a0 <init_module+0x221>
	for (i = 0; i < MAX_NUM_NODES; i++) {
 2a0:	49 83 fc 20          	cmp    $0x20,%r12
 2a4:	0f 85 32 ff ff ff    	jne    1dc <init_module+0x15d>
 2aa:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
 2b1:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 2b8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
		//spin_lock_init(&rh->evict_slots_lock);

		init_completion(&rh->cm_done);
	}
	server_rh.state = RDMA_INIT;
 2bf:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 2c9 <init_module+0x24a>
 2c6:	00 00 00 
	x->done = 0;
 2c9:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 2d3 <init_module+0x254>
 2d0:	00 00 00 
	init_waitqueue_head(&x->wait);
 2d3:	e8 00 00 00 00       	callq  2d8 <init_module+0x259>
	return kmalloc_order_trace(size, flags, order);
 2d8:	ba 09 00 00 00       	mov    $0x9,%edx
 2dd:	be c0 0c 00 00       	mov    $0xcc0,%esi
 2e2:	bf 00 00 20 00       	mov    $0x200000,%edi
 2e7:	e8 00 00 00 00       	callq  2ec <init_module+0x26d>
	init_completion(&server_rh.cm_done);

	my_data = kmalloc(PAGE_SIZE * 512, GFP_KERNEL);
	if (!my_data)
 2ec:	48 85 c0             	test   %rax,%rax
	my_data = kmalloc(PAGE_SIZE * 512, GFP_KERNEL);
 2ef:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 2f6 <init_module+0x277>
	if (!my_data)
 2f6:	0f 84 56 01 00 00    	je     452 <init_module+0x3d3>
	DEBUG_LOG(PFX "establish connection\n");
 2fc:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 303 <init_module+0x284>
 303:	74 0c                	je     311 <init_module+0x292>
 305:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 30c:	e8 00 00 00 00       	callq  311 <init_module+0x292>
	if (server) {
 311:	8b 1d 00 00 00 00    	mov    0x0(%rip),%ebx        # 317 <init_module+0x298>
			DEBUG_LOG(PFX "connect to server\n");
 317:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
	if (server) {
 31e:	85 db                	test   %ebx,%ebx
 320:	0f 84 db 00 00 00    	je     401 <init_module+0x382>
	struct sockaddr_in addr = {
 326:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 32c <init_module+0x2ad>
	struct rdma_cm_id *cm_id = rdma_create_id(&init_net,
 32c:	31 d2                	xor    %edx,%edx
 32e:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
 335:	41 b8 02 00 00 00    	mov    $0x2,%r8d
 33b:	b9 3f 01 00 00       	mov    $0x13f,%ecx
 340:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 347:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	struct sockaddr_in addr = {
 34e:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
 355:	00 
 356:	c7 45 d0 02 00 2c bd 	movl   $0xbd2c0002,-0x30(%rbp)
 35d:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	struct rdma_cm_id *cm_id = rdma_create_id(&init_net,
 360:	e8 00 00 00 00       	callq  365 <init_module+0x2e6>
	if (IS_ERR(cm_id)) 
 365:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
	struct rdma_cm_id *cm_id = rdma_create_id(&init_net,
 36b:	48 89 c3             	mov    %rax,%rbx
	if (IS_ERR(cm_id)) 
 36e:	76 0a                	jbe    37a <init_module+0x2fb>
		if (ret) 
 370:	85 c0                	test   %eax,%eax
 372:	0f 85 da 00 00 00    	jne    452 <init_module+0x3d3>
 378:	eb 4e                	jmp    3c8 <init_module+0x349>
	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&addr);
 37a:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
 37e:	48 89 c7             	mov    %rax,%rdi
	server_rh.cm_id = cm_id;
 381:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 388 <init_module+0x309>
	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&addr);
 388:	e8 00 00 00 00       	callq  38d <init_module+0x30e>
	if (ret) {
 38d:	85 c0                	test   %eax,%eax
 38f:	74 13                	je     3a4 <init_module+0x325>
		printk(KERN_ERR PFX "Cannot bind server address, %d\n", ret);
 391:	89 c6                	mov    %eax,%esi
 393:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 39a:	e8 00 00 00 00       	callq  39f <init_module+0x320>
 39f:	e9 ae 00 00 00       	jmpq   452 <init_module+0x3d3>
	ret = rdma_listen(cm_id, MAX_NUM_NODES);
 3a4:	be 20 00 00 00       	mov    $0x20,%esi
 3a9:	48 89 df             	mov    %rbx,%rdi
 3ac:	e8 00 00 00 00       	callq  3b1 <init_module+0x332>
	if (ret) {
 3b1:	85 c0                	test   %eax,%eax
 3b3:	74 13                	je     3c8 <init_module+0x349>
		printk(KERN_ERR PFX "Cannot listen to incoming requests, %d\n", ret);
 3b5:	89 c6                	mov    %eax,%esi
 3b7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 3be:	e8 00 00 00 00       	callq  3c3 <init_module+0x344>
 3c3:	e9 8a 00 00 00       	jmpq   452 <init_module+0x3d3>
		accept_k = kthread_run(accept_client, NULL, "accept thread");
 3c8:	83 ca ff             	or     $0xffffffff,%edx
 3cb:	31 f6                	xor    %esi,%esi
 3cd:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
 3d4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 3db:	e8 00 00 00 00       	callq  3e0 <init_module+0x361>
 3e0:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
 3e6:	48 89 c3             	mov    %rax,%rbx
 3e9:	77 08                	ja     3f3 <init_module+0x374>
 3eb:	48 89 c7             	mov    %rax,%rdi
 3ee:	e8 00 00 00 00       	callq  3f3 <init_module+0x374>
		if (!accept_k)
 3f3:	48 85 db             	test   %rbx,%rbx
		accept_k = kthread_run(accept_client, NULL, "accept thread");
 3f6:	48 89 1d 00 00 00 00 	mov    %rbx,0x0(%rip)        # 3fd <init_module+0x37e>
		if (!accept_k)
 3fd:	75 43                	jne    442 <init_module+0x3c3>
 3ff:	eb 51                	jmp    452 <init_module+0x3d3>
			DEBUG_LOG(PFX "connect to server\n");
 401:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 408 <init_module+0x389>
 408:	74 08                	je     412 <init_module+0x393>
 40a:	4c 89 e7             	mov    %r12,%rdi
 40d:	e8 00 00 00 00       	callq  412 <init_module+0x393>
			if ((ret = __connect_to_server(i, CONNECTION_FETCH))) 
 412:	31 f6                	xor    %esi,%esi
 414:	89 df                	mov    %ebx,%edi
 416:	e8 00 00 00 00       	callq  41b <init_module+0x39c>
 41b:	85 c0                	test   %eax,%eax
 41d:	75 33                	jne    452 <init_module+0x3d3>
			if ((ret = __connect_to_server(i, CONNECTION_EVICT))) 
 41f:	be 01 00 00 00       	mov    $0x1,%esi
 424:	89 df                	mov    %ebx,%edi
 426:	e8 00 00 00 00       	callq  42b <init_module+0x3ac>
 42b:	85 c0                	test   %eax,%eax
 42d:	75 23                	jne    452 <init_module+0x3d3>
		for (i = 0; i < MAX_NUM_NODES; i++) { 
 42f:	ff c3                	inc    %ebx
 431:	83 fb 20             	cmp    $0x20,%ebx
 434:	75 cb                	jne    401 <init_module+0x382>
		printk(PFX "Connections are established.\n");
 436:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 43d:	e8 00 00 00 00       	callq  442 <init_module+0x3c3>


	if (__establish_connections())
		goto out_free;

	printk(PFX "Ready on InfiniBand RDMA\n");
 442:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 449:	e8 00 00 00 00       	callq  44e <init_module+0x3cf>
	return 0;
 44e:	31 d2                	xor    %edx,%edx
 450:	eb 0a                	jmp    45c <init_module+0x3dd>

out_free:
	exit_rmm_rdma();
 452:	e8 00 00 00 00       	callq  457 <init_module+0x3d8>
	return -EINVAL;
 457:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
 45c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 460:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
 467:	00 00 
 469:	89 d0                	mov    %edx,%eax
 46b:	74 05                	je     472 <init_module+0x3f3>
 46d:	e8 00 00 00 00       	callq  472 <init_module+0x3f3>
 472:	48 83 c4 18          	add    $0x18,%rsp
 476:	5b                   	pop    %rbx
 477:	41 5c                	pop    %r12
 479:	41 5d                	pop    %r13
 47b:	5d                   	pop    %rbp
 47c:	c3                   	retq   

Disassembly of section .exit.text:

0000000000000000 <cleanup_module>:
{
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	41 56                	push   %r14
   6:	41 55                	push   %r13
   8:	41 54                	push   %r12
		if (rdma_handles_evic[i]->cm_id)
   a:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
{
  11:	53                   	push   %rbx
		if (rdma_handles[i]->cm_id)
  12:	49 c7 c5 00 00 00 00 	mov    $0x0,%r13
{
  19:	31 db                	xor    %ebx,%ebx
  1b:	4d 89 e6             	mov    %r12,%r14
		if (rdma_handles[i]->cm_id)
  1e:	49 8b 44 1d 00       	mov    0x0(%r13,%rbx,1),%rax
  23:	48 8b b8 28 01 00 00 	mov    0x128(%rax),%rdi
  2a:	48 85 ff             	test   %rdi,%rdi
  2d:	74 05                	je     34 <cleanup_module+0x34>
			rdma_disconnect(rdma_handles[i]->cm_id);
  2f:	e8 00 00 00 00       	callq  34 <cleanup_module+0x34>
		if (rdma_handles_evic[i]->cm_id)
  34:	49 8b 04 1c          	mov    (%r12,%rbx,1),%rax
  38:	48 83 b8 28 01 00 00 	cmpq   $0x0,0x128(%rax)
  3f:	00 
  40:	74 11                	je     53 <cleanup_module+0x53>
			rdma_disconnect(rdma_handles[i]->cm_id);
  42:	49 8b 44 1d 00       	mov    0x0(%r13,%rbx,1),%rax
  47:	48 8b b8 28 01 00 00 	mov    0x128(%rax),%rdi
  4e:	e8 00 00 00 00       	callq  53 <cleanup_module+0x53>
  53:	48 83 c3 08          	add    $0x8,%rbx
	for (i = 0; i < MAX_NUM_NODES; i++) {
  57:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
  5e:	75 be                	jne    1e <cleanup_module+0x1e>
	remove_proc_entry("rmm", NULL);
  60:	31 f6                	xor    %esi,%esi
  62:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  69:	45 31 e4             	xor    %r12d,%r12d
  6c:	e8 00 00 00 00       	callq  71 <cleanup_module+0x71>
		struct rdma_handle *rh = rdma_handles[i];
  71:	4b 8b 5c 25 00       	mov    0x0(%r13,%r12,1),%rbx
		if (!rh) continue;
  76:	48 85 db             	test   %rbx,%rbx
  79:	0f 84 de 01 00 00    	je     25d <cleanup_module+0x25d>
		if (rh->recv_buffer) {
  7f:	48 83 7b 38 00       	cmpq   $0x0,0x38(%rbx)
  84:	74 26                	je     ac <cleanup_module+0xac>
			ib_dma_unmap_single(rh->device, rh->recv_buffer_dma_addr,
  86:	48 8b 83 30 01 00 00 	mov    0x130(%rbx),%rax
	return dma_unmap_page_attrs(dev, addr, size, dir, attrs);
  8d:	48 8b 73 60          	mov    0x60(%rbx),%rsi
  91:	b9 02 00 00 00       	mov    $0x2,%ecx
  96:	ba 00 10 00 00       	mov    $0x1000,%edx
  9b:	48 8b 38             	mov    (%rax),%rdi
  9e:	e8 00 00 00 00       	callq  a3 <cleanup_module+0xa3>
			kfree(rh->recv_buffer);
  a3:	48 8b 7b 38          	mov    0x38(%rbx),%rdi
  a7:	e8 00 00 00 00       	callq  ac <cleanup_module+0xac>
		if (rh->dma_buffer) {
  ac:	48 83 7b 40 00       	cmpq   $0x0,0x40(%rbx)
  b1:	74 23                	je     d6 <cleanup_module+0xd6>
			ib_dma_unmap_single(rh->device, rh->dma_addr,
  b3:	48 8b 83 30 01 00 00 	mov    0x130(%rbx),%rax
  ba:	48 8b 73 68          	mov    0x68(%rbx),%rsi
  be:	31 c9                	xor    %ecx,%ecx
  c0:	ba 00 10 10 00       	mov    $0x101000,%edx
  c5:	48 8b 38             	mov    (%rax),%rdi
  c8:	e8 00 00 00 00       	callq  cd <cleanup_module+0xcd>
			kfree(rh->dma_buffer);
  cd:	48 8b 7b 40          	mov    0x40(%rbx),%rdi
  d1:	e8 00 00 00 00       	callq  d6 <cleanup_module+0xd6>
		if (rh->qp && !IS_ERR(rh->qp)) rdma_destroy_qp(rh->cm_id);
  d6:	48 8b 83 40 01 00 00 	mov    0x140(%rbx),%rax
  dd:	48 85 c0             	test   %rax,%rax
  e0:	74 14                	je     f6 <cleanup_module+0xf6>
  e2:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
  e8:	77 0c                	ja     f6 <cleanup_module+0xf6>
  ea:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
  f1:	e8 00 00 00 00       	callq  f6 <cleanup_module+0xf6>
		if (rh->cq && !IS_ERR(rh->cq)) ib_destroy_cq(rh->cq);
  f6:	48 8b bb 38 01 00 00 	mov    0x138(%rbx),%rdi
  fd:	48 85 ff             	test   %rdi,%rdi
 100:	74 0e                	je     110 <cleanup_module+0x110>
 102:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
 109:	77 05                	ja     110 <cleanup_module+0x110>
 10b:	e8 00 00 00 00       	callq  110 <cleanup_module+0x110>
		if (rh->cm_id && !IS_ERR(rh->cm_id)) rdma_destroy_id(rh->cm_id);
 110:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
 117:	48 85 ff             	test   %rdi,%rdi
 11a:	74 0e                	je     12a <cleanup_module+0x12a>
 11c:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
 123:	77 05                	ja     12a <cleanup_module+0x12a>
 125:	e8 00 00 00 00       	callq  12a <cleanup_module+0x12a>
		if (rh->mr && !IS_ERR(rh->mr))
 12a:	48 8b bb 48 01 00 00 	mov    0x148(%rbx),%rdi
 131:	48 85 ff             	test   %rdi,%rdi
 134:	74 0e                	je     144 <cleanup_module+0x144>
 136:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
 13d:	77 05                	ja     144 <cleanup_module+0x144>
			ib_dereg_mr(rh->mr);
 13f:	e8 00 00 00 00       	callq  144 <cleanup_module+0x144>
		kfree(rdma_handles[i]);
 144:	4b 8b 7c 25 00       	mov    0x0(%r13,%r12,1),%rdi
 149:	e8 00 00 00 00       	callq  14e <cleanup_module+0x14e>
		kfree(rpc_pools[i]);
 14e:	49 8b bc 24 00 00 00 	mov    0x0(%r12),%rdi
 155:	00 
 156:	e8 00 00 00 00       	callq  15b <cleanup_module+0x15b>
		kfree(sink_pools[i]);
 15b:	49 8b bc 24 00 00 00 	mov    0x0(%r12),%rdi
 162:	00 
 163:	e8 00 00 00 00       	callq  168 <cleanup_module+0x168>
		rh = rdma_handles_evic[i];
 168:	4b 8b 1c 26          	mov    (%r14,%r12,1),%rbx
		if (!rh) continue;
 16c:	48 85 db             	test   %rbx,%rbx
 16f:	0f 84 e8 00 00 00    	je     25d <cleanup_module+0x25d>
		if (rh->recv_buffer) {
 175:	48 83 7b 38 00       	cmpq   $0x0,0x38(%rbx)
 17a:	74 26                	je     1a2 <cleanup_module+0x1a2>
			ib_dma_unmap_single(rh->device, rh->recv_buffer_dma_addr,
 17c:	48 8b 83 30 01 00 00 	mov    0x130(%rbx),%rax
 183:	48 8b 73 60          	mov    0x60(%rbx),%rsi
 187:	b9 02 00 00 00       	mov    $0x2,%ecx
 18c:	ba 00 10 00 00       	mov    $0x1000,%edx
 191:	48 8b 38             	mov    (%rax),%rdi
 194:	e8 00 00 00 00       	callq  199 <cleanup_module+0x199>
			kfree(rh->recv_buffer);
 199:	48 8b 7b 38          	mov    0x38(%rbx),%rdi
 19d:	e8 00 00 00 00       	callq  1a2 <cleanup_module+0x1a2>
		if (rh->dma_buffer) {
 1a2:	48 83 7b 40 00       	cmpq   $0x0,0x40(%rbx)
 1a7:	74 23                	je     1cc <cleanup_module+0x1cc>
			ib_dma_unmap_single(rh->device, rh->dma_addr,
 1a9:	48 8b 83 30 01 00 00 	mov    0x130(%rbx),%rax
 1b0:	48 8b 73 68          	mov    0x68(%rbx),%rsi
 1b4:	31 c9                	xor    %ecx,%ecx
 1b6:	ba 00 10 10 00       	mov    $0x101000,%edx
 1bb:	48 8b 38             	mov    (%rax),%rdi
 1be:	e8 00 00 00 00       	callq  1c3 <cleanup_module+0x1c3>
			kfree(rh->dma_buffer);
 1c3:	48 8b 7b 40          	mov    0x40(%rbx),%rdi
 1c7:	e8 00 00 00 00       	callq  1cc <cleanup_module+0x1cc>
		if (rh->qp && !IS_ERR(rh->qp)) rdma_destroy_qp(rh->cm_id);
 1cc:	48 8b 83 40 01 00 00 	mov    0x140(%rbx),%rax
 1d3:	48 85 c0             	test   %rax,%rax
 1d6:	74 14                	je     1ec <cleanup_module+0x1ec>
 1d8:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
 1de:	77 0c                	ja     1ec <cleanup_module+0x1ec>
 1e0:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
 1e7:	e8 00 00 00 00       	callq  1ec <cleanup_module+0x1ec>
		if (rh->cq && !IS_ERR(rh->cq)) ib_destroy_cq(rh->cq);
 1ec:	48 8b bb 38 01 00 00 	mov    0x138(%rbx),%rdi
 1f3:	48 85 ff             	test   %rdi,%rdi
 1f6:	74 0e                	je     206 <cleanup_module+0x206>
 1f8:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
 1ff:	77 05                	ja     206 <cleanup_module+0x206>
 201:	e8 00 00 00 00       	callq  206 <cleanup_module+0x206>
		if (rh->cm_id && !IS_ERR(rh->cm_id)) rdma_destroy_id(rh->cm_id);
 206:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
 20d:	48 85 ff             	test   %rdi,%rdi
 210:	74 0e                	je     220 <cleanup_module+0x220>
 212:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
 219:	77 05                	ja     220 <cleanup_module+0x220>
 21b:	e8 00 00 00 00       	callq  220 <cleanup_module+0x220>
		if (rh->mr && !IS_ERR(rh->mr))
 220:	48 8b bb 48 01 00 00 	mov    0x148(%rbx),%rdi
 227:	48 85 ff             	test   %rdi,%rdi
 22a:	74 0e                	je     23a <cleanup_module+0x23a>
 22c:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
 233:	77 05                	ja     23a <cleanup_module+0x23a>
			ib_dereg_mr(rh->mr);
 235:	e8 00 00 00 00       	callq  23a <cleanup_module+0x23a>
		kfree(rdma_handles_evic[i]);
 23a:	4b 8b 3c 26          	mov    (%r14,%r12,1),%rdi
 23e:	e8 00 00 00 00       	callq  243 <cleanup_module+0x243>
		kfree(rpc_pools_evic[i]);
 243:	49 8b bc 24 00 00 00 	mov    0x0(%r12),%rdi
 24a:	00 
 24b:	e8 00 00 00 00       	callq  250 <cleanup_module+0x250>
		kfree(sink_pools_evic[i]);
 250:	49 8b bc 24 00 00 00 	mov    0x0(%r12),%rdi
 257:	00 
 258:	e8 00 00 00 00       	callq  25d <cleanup_module+0x25d>
 25d:	49 83 c4 08          	add    $0x8,%r12
	for (i = 0; i < MAX_NUM_NODES; i++) {
 261:	49 81 fc 00 01 00 00 	cmp    $0x100,%r12
 268:	0f 85 03 fe ff ff    	jne    71 <cleanup_module+0x71>
	if (rdma_pd) {
 26e:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 275 <cleanup_module+0x275>
 275:	48 85 ff             	test   %rdi,%rdi
 278:	74 05                	je     27f <cleanup_module+0x27f>
		ib_dealloc_pd(rdma_pd);
 27a:	e8 00 00 00 00       	callq  27f <cleanup_module+0x27f>
	printk(KERN_INFO PFX "RDMA unloaded\n");
 27f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 286:	e8 00 00 00 00       	callq  28b <cleanup_module+0x28b>
}
 28b:	5b                   	pop    %rbx
 28c:	41 5c                	pop    %r12
 28e:	41 5d                	pop    %r13
 290:	41 5e                	pop    %r14
 292:	5d                   	pop    %rbp
 293:	c3                   	retq   
